---
title: '\ '
output:
  # word_document:
  #   toc: yes
  html_document:
    number_sections: yes
    toc: yes
    css: !expr here::here("global/style/style.css")
    highlight: kate
    pandoc_args: --shift-heading-level-by=-1
editor_options:
  markdown:
    wrap: 100
always_allow_html: yes
---

```{r, echo = F, message = F, warning = F}
library(tidyverse)
library(knitr)

## functions
source(here::here("global/functions/misc_functions.R"))

## default render
registerS3method("reactable_5_rows", "data.frame", reactable_5_rows)
knitr::opts_chunk$set(class.source = "tgc-code-block", render = reactable_5_rows)

## autograders
suppressMessages(source(here::here("lessons/ls05_across_autograder.R")))
```

## Introduction

You can perform a lot of different operations: selecting, filtering, mutating, summarizing. But what if you want to perform the same operation on 2 (or more!) variables at the same time ? Here comes in `across()` !

`across()` is more difficult than other {dplyr} verbs and this lesson only attempts to give you a basic mastery of it. The reason `across()` is more difficult is that you can feed it functions (and you have not yet learnt to write functions if you started The GRAPH Courses as a beginner).

We will come back to `across()` in an advanced manner at the end of the function chapter. See you then !

Nonetheless, we believe in you! And we think you can already handle an introduction to simple usages of `across()`.

Let's go !

![Fig: the `across()` verb.](images/custom_dplyr_across.png){width="400"}

## Learning objectives

1.  You will mutate across multiple columns using the `across()` function from the {dplyr} package.

2.  You will summarize over multiple variables using `across()`.

3.  You will have seen an example of a custom functions applied through `across()`

## Dataset

In this lesson, we will again (and for the last time for data wrangling) use data from the COVID-19 serological survey conducted in Yaounde, Cameroon.

```{r, message = F}
yaounde <- read_csv(here::here('data/yaounde_data.csv'))

# A smaller subset of variables
yao <- yaounde %>% select(
  age, age_category_3, sex, 
  weight_kg, height_cm,
  neighborhood, occupation,
  is_smoker, is_pregnant,
  symptoms, igg_result)

yao
```

For practice questions, we shall use the sarcopenia prevalence data you have encountered in previous lessons, from a cross-sectional study from India.

```{r, message = F, render = reactable_10_rows}
sarcopenia <- read_csv(here::here('data/sarcopenia_elderly.csv'))

sarcopenia <- 
  sarcopenia %>%
  # we must do this mutation to ensure that this category (factor variable) is not ill-interpreted as a numerical variable
  mutate(sex_male_1_female_0 = as.factor(sex_male_1_female_0))
```

## Motivation for `across()` !

We are going to do a quick data cleaning together to demonstrate the benefits of knowing `across()`.

```{r}
yao_smoker_sex_igg <-
  yao %>%
  select(is_smoker, sex, igg_result)
```

We will first write out the data cleaning solely with verbs you already know `filter()` and `mutate()`:

```{r}
yao_smoker_sex_igg %>%
  filter(!is.na(is_smoker) & !is.na(sex) & !is.na(igg_result)) %>%
  mutate(is_smoker = as.factor(is_smoker), 
         sex = as.factor(sex), 
         igg_result = as.factor(igg_result))
```

Here our `filter()` condition applies `!is.na()` condition to each column (`is_smoker`, `sex` and `igg_result`). The goal is to remove any entries that are `NA` for the variables `is_smoker`, `sex`, `igg_result`.

Our `mutate()` transformation converts columns one by one into factors.

`across()` allows you to apply the same filtering or transformation to multiple columns at the same time.

We can rewrite the code above using the `across()` syntax:

```{r, eval=F}
yao_smoker_sex_igg %>%
  # Across and Filter
  # we apply !is.na() across our 3 columns of interest
  filter(across(.cols = c(is_smoker, sex, igg_result), 
                .fns = ~ !is.na(.x)) %>%
  # this uses a "custom" function: a challenge in your learning journey!
           
  # Across and Mutate
  # we apply as.factor across our 3 columns of interest
  mutate(across(.cols = c(is_smoker, sex, igg_result),
                .fns = as.factor))
   # this uses a predefined R function: our focus on this lesson
```

This might seem very alien to you ! Let's break it down.

`across()` is always used **INSIDE** different {dplyr} verbs.

::: vocab
`across()` has two main arguments.

`.cols` which sounds like COLUMNS : selecting all the columns you want to act on simultaneously.

`.fns` which sounds like FUNCTIONS: defining the transformation you want to make on the columns you selected.
:::

Our `.cols` argument is a vector with the columns we care about: `c(is_smoker, sex, igg_result)`.

Our `.fns` function changes depending on if we are filtering or mutating. When mutating we are using a predefined R function `as.factor`. We will focus this lesson on the use of `across()` and R predefined functions.

::: challenge
When filtering, we define a more complex function, called a "custom" function.

Don't worry too much about understanding this line of code. It will be easier to understand what is going once you've learnt more about functions.

We will briefly look over another example at the end of the lesson but it's for those of you who are curious: it's not a learning requisite of the lesson.
:::

The advantage of `across()` is that it makes it clear we are applying the same transformation of each column. It makes it clear in our minds that these 3 columns need to be filtered in the same way, mutated in the same way. It can help you structure your code and, above all, structure the step-by-step process of your data wrangling.

### Summarizing across multiple columns

We have explored in depth how to summarize a variable into a single summary statistic. To get summary statistics over multiple variables (for example, the mean over height, weight and age), you can either duplicate your lines of code within the `summarize()` function, or use `across()`.

::: pro-tip
A rule of thumb, for any {dplyr} verb, the more duplicates you are writing, the better it would be to switch to using `across()`
:::

Here let's remind ourselves how to obtain multiple summarizing statistics using only `summarize()`:

```{r}
yao %>%
  summarize(mean_height = mean(height_cm),
            mean_weight = mean(weight_kg),
            mean_age = mean(age))
```

We see that in the code above, we have one line per variable that we want to summarize.

Let's see how we would write this summarizing operation using `across()`:

```{r}
yao %>%
  summarize(across(c(height_cm, weight_kg), 
                   mean))
```

In this code, the syntax makes it very clear that the same operation `mean` is being applied to the 2 variables (`c(height_cm, weight_kg)`). The resulting data frame keeps the original names of the variables and each column is 1 row: the mean of that variable.

::: practice
In the `sarcopenia` data set, `summarize()` the weight and height variables into their mean using `across()`.

Your output should be a data frame with two columns named as shown below:

| weight_kg | height_meters |
|-----------|---------------|
|           |               |

```{r, eval = FALSE}
Q_across_summarize <- 
  yao %>%
  ____________________________
```

```{r, include = FALSE}
.CHECK_Q_across_summarize()
.HINT_Q_across_summarize()
```
:::

Remember that if one of your summary statistics should result in `NA`, it is imperative to use the `na.rm=TRUE` argument to calculate the summary statistic without the `NA` values. `across()` has an argument for removing `NA`s:

```{r}
yao %>%
  summarize(across(.cols = c(height_cm, weight_kg), 
                   .fns = mean, 
                   na.rm = TRUE))
```

Now we have our means over 3 different variables, ensuring we do not have `NA` summary statistics.

But what if we wanted to compute the mean over all numerical variables within the `yao` dataset? The numerical variables are `age`, `weight_kg` and `height_cm`. We could list all 3 of them in a vector as we did above: `c(age, weight_kg, height_cm)` or we could instead select them with a condition:

I will briefly introduce a new condition: `where()`:

```{r}
yao %>%
  select(where(is.character))

yao %>% 
  select(where(is.factor))

yao %>% 
  select(where(is.numeric))
```

`where()` is a condition that can be read as "where it is true." It is used within {dplyr} verbs. Let's decompose the code above and the 3 resulting data frames. `where(is.character)` can be read as "where it is a character" i.e. "where `is.character()` is true." It will apply the manipulation to all variables of type character. Within select, it will apply the selection verb to only character variables, i.e. selecting them. The result is the same when combining `where()` with `is.factor()` ("where it is factor") and when fitting together `where()` with `is.numeric()` ("where it is numeric"). When we ran the code, we saw that we get 3 dataframes as output: one is the character type variables, one is the factor type variables (there are none), and one is the numeric type variables (there are 3, the ones we are interested in to calculate their mean).

::: side-note
If you were to run this:

```{r}
yao %>%
  select(is.character)
```

You would get the same result: all character type columns. However, you would also get a warning/error message from R indicating this is bad coding practice and that good coding practice is embedding your `is.character()` into `where()`. Let's be top-notch coders!
:::

::: practice
In the `sarcopenia` data set, select all the variables that have a numeric type using `where()` and `is.numeric()`.

```{r, eval = FALSE}
Q_where_numeric <- 
  yao %>%
  ____________________________
```

```{r, include = FALSE}
.CHECK_Q_where_numeric()
.HINT_Q_where_numeric()
```
:::

Let us now use the `where()` condition inside of `across()` to calculate the mean only across numeric type variables:

```{r}
yao %>%
  summarize(across(.cols= where(is.numeric), 
                   .fns = mean, 
                   na.rm = TRUE))
```

We cared about the mean, so we only cared about variables that are numeric. We replaced the list of variables in `.cols` by a condition.

::: practice
In the `sarcopenia` data set, calculate the median over all numeric type variables. Remember you have the R function `median()` for this. All numerical variables can be selected using `where()`. Make sure you do not include `NA` values, else medians will be `NA`.

```{r, eval = FALSE}
Q_across_median<- 
  yao %>%
  ____________________________
```

```{r, include = FALSE}
.CHECK_Q_across_median()
.HINT_Q_across_median()
```
:::

You might find it confusing or inconvenient that the means would be named simply with the column name instead of a representative name such as `mean_XX` or `XX_mean` (where `XX` is the original variable name). If you compare to the summarize call without `across()` above, you see that we could define the names of the columns (`mean_height`, `mean_weight`).

Within a call to `across()` it is possible to play with the naming of resulting columns using the arguments `.names` (as for `.fns` and `.cols`, its name is intuitive).

Here is how we would do a taylored naming in `across()` :

```{r}
yao %>%
  summarize(across(.cols = where(is.numeric), 
                   .fns = mean, 
                   na.rm = TRUE,
                   .names = "{.col}_mean"))
```

Or like this :

```{r}
yao %>%
  summarize(across(.cols = where(is.numeric), 
                   .fns = mean, 
                   na.rm = TRUE,
                   .names = "mean_{.col}"))
```

We use the `.names` argument of `across()` to set the names of the resulting columns. `"mean_"` is just a normal string while `"{.col}"` "references" the column name. Note that we refer to each column individually for the naming. This means we write `{.col}` instead of `{.cols}` (as in classical English spelling, one has an "s" for plural while the other does not).

::: practice
In the `sarcopenia` data set, calculate the median over all numeric type variables, as the question above, but define the `.names` argument to have all columns named `"median_ORIGINAL_COLUMN_NAME"`.

```{r, eval = FALSE}
Q_across_median_named<- 
  yao %>%
  ____________________________
```

```{r, include = FALSE}
.CHECK_Q_across_median_named()
.HINT_Q_across_median_named()
```
:::

Another argument in favor of using `summarize()` on each variable instead of using `across()` could be that you can calculate multiple summary statistics. Such as this:

```{r}
yao %>%
  summarize(
    # means
    mean_height = mean(height_cm),
    mean_weight = mean(weight_kg),
    mean_age = mean(age),
    # standard deviations
    sd_height = sd(height_cm),
    sd_weight = sd(weight_kg),
    sd_age = sd(age))
```

You can calculate multiple statistics but that's really starting to be a lot of repetitive code. `across()` allows you to have the same result with 2 lines of code:

```{r}
yao %>%
  summarise(across(.cols = where(is.numeric), 
                   .fns = list(mean = mean, stand_dev = sd)))
```

Here it is clear that on all numeric type variables of the data set, we want to calculate the mean and the standard deviation. We can do so by providing the `.fns` argument of `across()` with a list. Small joke: `.fns` isn't "functions" abbreviated plural for nothing ! If we could only apply one function within `across()`, it would have been named `.fn` (function singular abbreviated).

This time, for the naming, `across()` takes care of naming the resulting summary statistic columns. The syntax is : `list(desired_name_1 = function_1, desired_name_2 = function_2)`.

::: practice
In the `sarcopenia` data set, calculate the median and the standard deviation over all numeric type variables.

```{r, eval = FALSE}
Q_across_median_sd<- 
  yao %>%
  ____________________________
```

```{r, include = FALSE}
.CHECK_Q_across_median_sd()
.HINT_Q_across_median_sd()
```
:::

Let's see how you could control the naming even more, when operating on a list of functions:

```{r}
yao %>%
  summarise(across(.cols = where(is.numeric), 
                   .fns = list(mean = mean, sd = sd),
                   .names = "{.fn}_{.col}"))
```

Here we reference the name of the function using `{.fn}` and the name of the column with `{.col}`. It is important to note that both abbreviations are singular! They are singular because they reference the function and the column one by one. Within the `across()` procedure it takes the functions and the columns one by one and for each one, takes the function name, such as `mean`, and the column name, such as `age`, and makes the summary statistic `mean_age` (i.e. `{.fn}`=`mean` and `{.col}`=`age`).

::: practice
In the `sarcopenia` data set, calculate the median and the standard deviation over all numeric type variables, naming them `"new_variable_FUNCTION_COLUMN_NAME"`.

```{r, eval = FALSE}
Q_across_median_sd_named<- 
  yao %>%
  ____________________________
```

```{r, include = FALSE}
.CHECK_Q_across_median_sd_named()
.HINT_Q_across_median_sd_named()
```
:::

### Mutating across multiple columns

We have extensively looked into summarizing across multiple variables. However, there are other operations which can be performed across multiple variables. One such example would be `mutate()`.

We saw using `where()` above that none of our variables were factors. But so many of them should be:

```{r}
yao %>%
  mutate(age_category_3 = as.factor(age_category_3), 
         sex = as.factor(sex),
         neighborhood = as.factor(neighborhood), 
         occupation = as.factor(occupation),
         is_smoker = as.factor(is_smoker), 
         is_pregnant = as.factor(is_pregnant),
         symptoms = as.factor(symptoms), 
         igg_result = as.factor(igg_result))
```

This code does the job but SUCH repetition ! And remember that `yao` is only a subset of the full `yaounde` dataset.

Let's see how we would write these multiple transformations using `across()`:

```{r}
yao %>%
  mutate(across(
    # all columns we want as factors
    .cols = c(age_category_3, sex,
              neighborhood, occupation,
              is_smoker, is_pregnant,
              symptoms, igg_result), 
    # factor transformation            
    .fns = as.factor))
```

Here we list all the columns using the `c()` vector and we are aware they are all undergoing the same transformation: `.fns = as.factor`.

::: practice
In the `sarcopenia` data set, transform the sex, marital status, socioeconomic status, and grip speed in meter per seconds categorization into factors using `mutate()` and `across()`.

```{r, eval = FALSE}
Q_across_mutate<- 
  yao %>%
  ____________________________
```

```{r, include = FALSE}
.CHECK_Q_across_mutate()
.HINT_Q_across_mutate()
```
:::

The list of all the columns we want as factors is still quite long. We can also apply `across()` by defining which columns SHOULD NOT be transformed:

```{r}
yao %>%
  mutate(across(.cols = !c(age, weight_kg, height_cm,), 
                .fns = as.factor))
```

Here, there are less columns that should be "left untouched" so it is easier to list them and then to negate them by the `!` operator. The condition reads as: apply `as.factor()` across all columns but not on age, weight, and height variables.

As we have seen exploring `where()`, these 3 variables are the numeric type variables of the `yao` dataset, so we can rewrite the negation of above using `where()`:

```{r}
yao %>%
  mutate(across(!where(is.numeric), 
                as.factor))
```

We are excluding from the factor transformation the same variables (age, weight, height), but using the `where(is.numeric)` condition, combined with the negation `!`.

Finally, another way to write this, if we are sure all our character type variables should be factors:

```{r}
yao %>%
  mutate(across(where(is.character()), 
                as.factor))
```

Using this condition implies that all numerical variables have been made numeric (they are not encoded as strings) and that all character type variables are categories.

::: practice
In the `sarcopenia` data set, transform all numeric type variables into integers using `mutate()`, `across()`, and `as.integer()`.

```{r, eval = FALSE}
Q_across_mutate_integer<- 
  yao %>%
  ____________________________
```

```{r, include = FALSE}
.CHECK_Q_across_mutate_integer()
.HINT_Q_across_mutate_integer()
```
:::

## Writing your custom function to apply "across" multiple columns

::: challenge
This is clearly a CHALLENGE for your level !

There are extensive predefined R functions that you can use in `dplyr::across()` but once in a while, you need to write your own function.
:::

Coming back to our initial cleaning example. This code allows to drop `NA` values across 3 different columns of interest:

```{r, eval=F}
yao %>%
  filter(across(.cols = c(is_smoker, sex, igg_result), 
                .fns = ~ !is.na(.x))) 
```

::: key-point
Essential components of the CUSTOM function:

The **tilda** `~` introduces your function.

The `.x` **references the columns** one by one across which you are applying the function: it allows to apply the function on the variables one by one.
:::

Essentially this code takes `is_smoker`, drops rows that are `NA`, then takes `sex` and drops rows that are `NA`, and then takes `igg_results` to drop the `NA` values.

You may also want to drop the `NA` values everywhere, the following code would allow you to do so:

```{r, eval=F}
yao %>%
  filter(across(.cols = everything(), 
                .fns = ~ !is.na(.x))) 
```

We use the condition `everything()` that we have seen previously to apply a function over each variable of the data set.

Feel free to keep this code snippet and use it, if useful, in your future data wrangling tasks.

::: practice
In the `sarcopenia` data set, remove all `NA` values from all the different variables (remember you can use `everything()`). Do so using `filter()` and `across()`

```{r, eval = FALSE}
Q_across_filter_na<- 
  yao %>%
  ____________________________
```

```{r, include = FALSE}
.CHECK_Q_across_filter_na()
.HINT_Q_across_filter_na()
```
:::

Let's see another example of using an R function with a condition. Let's capitalize all the strings in the dataset:

```{r}
yao %>%
  mutate(across(.cols = where(is.character), 
                .fns = ~toupper(.x)))
```

We select the columns using `where(is.character)`, which takes all variables where the type is character. The function is the R function `toupper()` which converts string letters to uppercase (as the name indicates). Same as before, the tilda `~` introduces the function and the `.x` references the variables one by one.

::: practice
In the `sarcopenia` data set, transform all the character type variables, using `across()` and `mutate()` to lowercase using `tolower()`.

```{r, eval = FALSE}
Q_across_mutate_lowercase<- 
  yao %>%
  ____________________________
```

```{r, include = FALSE}
.CHECK_Q_across_mutate_lowercase()
.HINT_Q_across_mutate_lowercase()
```
:::

## Recap !

::: recap
`across()` can be used inside many different {dplyr} verbs:

-   `filter(across(multiple_columns, function(s) to apply))`

-   `mutate(across(multiple_columns, function(s) to apply))`

-   `summarize(across(multiple_columns, function(s) to apply))`

The `statement defining multiple columns` can be:

-   a list of names : `c("height_m", "weight_kg", "age")` OR `c(height_m, weight_kg)`

-   a condition: `!sex` OR `where(is.numeric)`

The `function(s) to apply across all columns` can be:

-   a predefined function of R (such as `as.factor`, `mean` etc.)

-   a list of functions (such as `list(mean, sd)` or `list(as.numeric, mean)`)

-   a custom function
:::

## Wrap up !

This was your first approach to `across()`: congrats for making it through ! Remember the power of combination of `across()` and other verbs. If you feel a summarizing or mutation operation is identical for more than one variable, then usually you should think of using `across()`.

In the upcoming lessons we will see some more data wrangling verbs: see you soon !
