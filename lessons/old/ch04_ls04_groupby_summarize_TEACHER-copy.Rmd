---
title: '\ '
output:
  # word_document:
  #   toc: yes
  html_document:
    number_sections: yes
    toc: yes
    css: !expr here::here("global/style/style.css")
    highlight: kate
    pandoc_args: --shift-heading-level-by=-1
editor_options:
  markdown:
    wrap: 100
always_allow_html: yes
---

```{r, echo = F, message = F, warning = F}
library(tidyverse)
library(knitr)

## functions
source(here::here("global/functions/misc_functions.R"))

## default render
registerS3method("reactable_5_rows", "data.frame", reactable_5_rows)
knitr::opts_chunk$set(class.source = "tgc-code-block", render = reactable_5_rows)

## autograders
suppressMessages(source(here::here("ch04_data_wrangling/lessons/ls04_groupby_summarize_autograder.R")))
```

<!-- # Data wrangling: grouping and summarizing -->

## Introduction

Last lesson of this data wrangling chapter! I hope you are slowly feeling like data wrangling masters. In this lesson we will discover the `summarize` and `group_by` verbs from {dplyr}. The first is essential to quickly obtain summary statistics from data and the second is an important data manipulation to handle operations on groups.

------------------------------------------------------------------------

## Learning objectives

1.  You will use `dplyr::summarize()` to extract summary statistics from the data.

2.  You will use `dplyr::group_by()` to group variables before performing operations or transformations on them.

3.  You will know how to use `dplyr::count()` as a handy function to count groups.

------------------------------------------------------------------------

## The Yaounde COVID-19 dataset

In this lesson, we use again the COVID-19 survey from Yaounde

```{r, message = F}
yaounde <- read_csv(here::here('ch04_data_wrangling/data/yaounde_data.csv'))
## a smaller subset of variables
yao <- yaounde %>% select(neighborhood, is_smoker, occupation, 
                          treatment_combinations, symptoms, 
                          age, sex, weight_kg, height_cm, 
                          igg_result)
yao
```

## Small data cleaning using what you've learnt!

Here you use `dplyr::filter()`. The goal is to remove any entries that are `NA` for the variables `is_smoker`, `sex`, `igg_result`.

As a second step, using `dplyr::mutate()`, we want to make sure these variables are factors.

```{r}
yao <- yao %>%
  filter(!is.na(is_smoker) & !is.na(sex) & !is.na(igg_result)) %>%
  mutate(is_smoker = as.factor(is_smoker), 
         sex = as.factor(sex), 
         igg_result = as.factor(igg_result))
```

::: side-note
There is a more optimal coding way to do this which we will explore in the next lesson, using the verb `across()`.

```{r, eval=F}
yao <- yao %>%
  filter(across(.cols = c(is_smoker, sex, igg_result), 
                .fns = ~ !is.na(.x))) %>%
  mutate(across(.cols = c(is_smoker, sex, igg_result),
                .fns = as.factor))
```
:::

## Introducing `dplyr::summarize()`

`dplyr::summarize()` creates a new data frame with the desired summary statistics (mean, standard deviation, etc.)

### Basic summarizing operations

::: key-point
-   Looking at the **center** of a distribution: mean [`mean()`], median [`median()`]

-   Looking at the **spread** of a distribution: standard deviation [`sd()`], interquartile range[`IQR()`], median absolute deviation [`mad()`]

-   Looking at the **range** of a distribution: minimum [`min()`], maximum [`max()`], quantiles [`q25()`, `q50()`, `q75()`, `quantile()`]

-   Finding the **position** within a variable: first element [`first()`], last element [`last()`], element number n \`[nth()]\`

-   **Counting** a variable: count all elements (including repetitions) [`n()`], count all distinct elements [`n_distinct()`]

-   Applying a **logical** to a variable: include any [`any()`], include all [`all()`]
:::

Let's learn all we can about the age distribution in our dataset!

```{r}
yao %>% 
summarise(
    n = n(),
    q25 = quantile(age, .25, na.rm = TRUE),
    q50 = quantile(age, .50, na.rm = TRUE),
    q75 = quantile(age, .75, na.rm = TRUE),
    avg_age = mean(age, na.rm = TRUE),
    sd_age  = sd(age, na.rm = TRUE),
    min_age = min(age, na.rm = TRUE),
    max_age = max(age, na.rm = TRUE)
  )
```

::: watch-out
`na.rm = TRUE` removes NA values, a useful option, as `NA` values would lead to the summary statistic also being equal to `NA`.

Whether in {dplyr} wrangling, or just using the different summarizing operations, `na.rm` is an argument of each of the functions (`min`, `max` etc.) and it is good practice to feed it as an argument.
:::

::: practice
Summarize the variable `weight_kg` into quartiles (`q25`, `q50`, `q75`)

```{r, eval = F,echo=FALSE}
q1 <- "YOUR_ANSWER_HERE"
.check_q1()
.hint_q1()
```
:::

## Introducing `dplyr::group_by()`

`dplyr::group_by()` allows to \*\*group by\*\* a variable

Then perform operations "by groups" in this variable.

::: watch-out
Use `dplyr::ungroup()` as soon as you are done with your operations per groups

Otherwise the data will remain grouped when you use it in the future.

This can lead to coding or analysis errors.
:::

### Classical structure of `dplyr::group_by()`

We can use `dplyr::group_by()` on the treatment combinations in the dataset to know how many of each kind were received by the patients.

`dplyr::group_by()` "lumps" together all the identical treatments

And `summarize(N=n())` counts each unique treatment and puts this count in a new column `N`.

Of high importance, we `ungroup` at the end of our operation.

Else the data will remain "lumped" together by treatments.

::: key-point
`dplyr::arrange()` is a useful `dplyr` function to view the data in an organized function.

`desc` has been introduced in the `dplyr::mutate()` lesson: it arranges the variable from its largest to smallest value.
:::

```{r}
yao %>%
  group_by(treatment_combinations) %>%
  summarize(N=n()) %>%
  ungroup() %>%
  arrange(desc(N))
```

::: practice
What is the average weight of all smoker options in the questionnaire? You should name your average weight column `weight_mean`.

```{r, eval = F,echo=FALSE}
q2 <- "YOUR_ANSWER_HERE"
.check_q2()
.hint_q2()
```
:::

### Nested Groupings

We can group by several variables.

Grouping by several variables consists in making groups based on the different unique combinations.

Here we create all the individual combinations for smokers, gender, and positive or negative IgG results:

`dplyr::group_by()` creates all the unique combinations (for example: "Smoker-Male-Positive" or "Smoker-Female-Negative" etc.)

And look at medians and standard deviations for age:

`dplyr::summarize()` calculates the groups' median and standard deviation.

```{r}
yao %>%
  group_by(is_smoker, sex, igg_result) %>%
  summarize(age_median = median(age, na.rm = TRUE),
            age_std = sd(age, na.rm = TRUE)) %>%
  ungroup()
```

::: watch-out
When you are grouping by a factors' variable, you need to add the argument `.drop = FALSE` in your `dpylr::group_by()` call

This allows to include empty groups (i.e. combinations that do not exist) in your operations.
:::

For example, if you look for the combination "Smoker-Female-Positive", you will find that it is absent from the grouping and subsequent summarizing operation.

This is because this combination does not exist.

If you want to have it included (with an age and standard deviation as `NA` ) then you need to set `.drop=FALSE`

```{r}
yao %>%
  group_by(is_smoker, sex, igg_result) %>%
  summarize(age_median = median(age, na.rm = TRUE),
            age_std = sd(age, na.rm = TRUE)) %>%
  ungroup() %>%
  filter(is_smoker=="Smoker", 
         sex=="Female",
         igg_result=="Positive")
```

You can see the difference below. When setting `.drop=FALSE`

```{r}
yao %>%
  group_by(is_smoker, sex, igg_result, .drop = FALSE) %>%
  summarize(age_median = median(age, na.rm = TRUE),
            age_std = sd(age, na.rm = TRUE)) %>%
  ungroup() %>%
  filter(is_smoker=="Smoker", 
         sex=="Female",
         igg_result=="Positive")
```

::: practice
Let's have a look at some statistics for IgG results grouped by sex and neighborhood (grouping by 3 variables). 

We will be looking at some statistics for the `weight_kg` variable: the interquartile range (`weight_IQR`, the function is presented at the beginning of the lesson) and the median (`weight_median`). 

Base yourself on the example above (i.e. removing NAs with `na.rm=TRUE` and not dropping any groups during the grouping `.drop=FALSE`).

```{r, eval = F,echo=FALSE}
q3 <- "YOUR_ANSWER_HERE"
.check_q3()
.hint_q3()
```
:::

### See your grouping variables

In the eventuality where you are getting weird results in your data,

that your wrangling is 500 lines of code,

and that you may have forgotten an `ungroup`,

it could be useful to check by what variables your data is currently grouped.

You can do this with `dplyr::group_vars()`:

```{r,eval=FALSE,echo=TRUE}
yao %>%
  group_by(igg_result, sex) %>%
  group_by(igg_result, age) %>%
  group_vars()
```

::: watch-out
If you grouped the data by one variable and then call again `dpylr::group_by()` with another variable, `dpylr::group_by()` overrides the previous grouping by default.

To add an additional grouping to an ALREADY GROUPED dataset,

You can call `dpylr::group_by()` with the `.add = TRUE` argument.
:::

For example, if you wanted to add a grouping by `age` to our initial grouping you would write:

```{r,eval=FALSE,echo=TRUE}
yao %>%
  group_by(igg_result, sex) %>%
  group_by(age, .add=TRUE) %>%
  group_vars()
```

## Introducing `dplyr::count()`

The `dplyr::count()` function wraps a bunch of things into one beautiful friendly line of code to help you find counts of observations by group.

Let's use `dplyr::count()` on our `occupation` variable.

Please note, doing `count(occupation)` is the same as doing `group_by(occupation) %>% summarize(n())`

(as we did above for treatment combinations).

```{r}
yao %>%
  count(occupation)
```

We can also apply `dplyr::count()` in a nested fashion.

```{r}
yao %>%
  count(occupation, sex)
```

::: practice
Count how many women did not have symptoms? Use count and then filter to only have the results for women (use the scaffoled presented below).

```{r, eval = F,echo=FALSE}
q4 <- "yao %>%
  count( ) %>%
  filter()"

.check_q4()
.hint_q4()

```
:::

## Contributors {.unlisted .unnumbered}

The following team members contributed to this lesson:

`r tgc_contributors_list(ids = c("lolovanco", "avallecam", "kendavidn"))`

## References {.unlisted .unnumbered}

Some material in this lesson was adapted from the following sources:

-   Horst, A. (2022). *Dplyr-learnr*. <https://github.com/allisonhorst/dplyr-learnr> (Original work published 2020)

-   *Group by one or more variables*. (n.d.). Retrieved 21 February 2022, from <https://dplyr.tidyverse.org/reference/group_by.html>

-   *Summarise each group to fewer rows*. (n.d.). Retrieved 21 February 2022, from <https://dplyr.tidyverse.org/reference/summarize.html>

Artwork was adapted from:

-   Horst, A. (2022). *R & stats illustrations by Allison Horst*. <https://github.com/allisonhorst/stats-illustrations> (Original work published 2018)

```{r, include = F}
```
