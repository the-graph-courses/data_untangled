---
title: '\ '
output:
  # word_document:
  #   toc: yes
  html_document:
    number_sections: yes
    toc: yes
    css: !expr here::here("global/style/style.css")
    highlight: kate
    pandoc_args: --shift-heading-level-by=-1
editor_options:
  markdown:
    wrap: 100
  canonical: true
  chunk_output_type: inline
always_allow_html: yes
---

```{r, echo = F, message = F, warning = F}
if(!require(pacman)) install.packages("pacman")
pacman::p_load(knitr, 
               here, 
               janitor,
               tidyverse)

## functions
source(here::here("global/functions/misc_functions.R"))

## default render
registerS3method("reactable_10_rows", "data.frame", reactable_10_rows)
knitr::opts_chunk$set(class.source = "tgc-code-block", render = reactable_10_rows)

## autograders
suppressMessages(source(here::here("lessons/ls06_group_by_other_verbs_autograder.R")))
```

<!-- # Data wrangling: grouping with other verbs -->

## Introduction

In the last lesson, you learned how to group data using `group_by()` from {dplyr} and how to combine `group_by()` with `summarize()`. 

In this lesson, we are going to see how to use `group_by()` with other verbs like `filter()`, `mutate()`, and `arrange()`, which you have all seen before. 
You'll be an expert of grouping variables and manipulating them by the end of this short lesson.

Let's get started.

![Fig: the different ways of using `group_by()`](images/custom_dplyr_group_by_other_verbs.png){alt="Fig: the different ways of using group_by()." width="400"}

## Learning objectives

1.  You will be able to use `group_by()` with `select()`

2.  You will be able to use `group_by()` with `arrange()`

3.  You will be able to use `group_by()` with `filter()`

4.  You will be able to use `group_by()` with `mutate()`

## Packages

This lesson will require the tidyverse suite of packages:

```{r}
if(!require(pacman)) install.packages("pacman")
pacman::p_load(tidyverse)
```

## Datasets

In this lesson, we will again use data from the COVID-19 serological survey conducted in Yaounde, Cameroon.

We will make a few transformations to our data. First we'll select a few variables of interest and then we'll transform several of them into factors using `across()` (this is a bit advanced material, we will see it in depth in the next lesson). 

```{r, message = F, render = reactable_10_rows}
# Import and view the dataset
yaounde <- read_csv(here::here('data/yaounde_data.csv')) 
  
yao <- 
  yaounde %>% 
  select(age_category, sex,
         weight_kg,
         occupation,
         igg_result, igm_result) %>%
  # This allows us to make all columns except weight_kg into factors
  # We will learn about across next lesson !
  mutate(across(!weight_kg,
         ~as.factor(.x))) %>%
  # For nicer prints, we will reorder levels of the age_category
  mutate(age_category = factor(age_category, 
                               levels = c("5 - 14",
                                          "15 - 29",
                                          "30 - 44",
                                          "45 - 64",
                                          "65 +")))

yao
```

For practice questions, we will also the sarcopenia data set. 

```{r, message = F, render = reactable_10_rows}
sarcopenia <- read_csv(here::here('data/sarcopenia_elderly.csv'))

sarcopenia
```

## {dplyr} Verbs that are unaffected by groupings

Before we get into the effects of grouping, let's have a look into which {dplyr} verbs are unaffected by grouped data. 

`rename()` and `relocate()` give the same output on grouped and ungrouped data because they only affect the name or position of targeted columns. 

## Groupings' effect on `select()` 

As demonstrated in the previous lesson, there is a slight effect of `group_by()` on `select()`. `select()` extracts the desired columns, independently of the groupings, but preserves the grouping columns even if they are not selected. Here is a quick reminder: 

```{r, message = F, render = reactable_10_rows}
yao %>%
  group_by(sex) %>%
  select(age_category)
```
We could have expected the resulting data frame to be composed of only 1 variable: age categories. However, although we wanted to select just the age category variable, the data is grouped by gender so `select()` preserves the `sex` variable when selecting. 

## Groupings' effect on `arrange()`

`arrange()` is used to reorder data based on defined variables. 

::: key-point
`arrange()` is insensitive to groupings, unless we set its argument `.by_group` to  `TRUE`. 
:::

Let's compare with and without this argument to see the difference. 

Let's select the `age_category`, `sex` and `weight_kg` and then let's group by age categories and gender. 

```{r, message = F, render = reactable_10_rows}
yao %>%
  select(age_category, sex, weight_kg) %>%
  group_by(age_category, sex) 
```
Then we'll see an example of arranging by respondent's weights. We are interested in seeing whom are the heaviest persons so we will be arranging using the `desc()` function. 

```{r, message = F, render = reactable_10_rows}
yao %>%
  select(age_category, sex, weight_kg) %>%
  group_by(age_category, sex) %>%
  arrange(desc(weight_kg))
```
Here we see that when we arrange by weight in a descending order, then we see that the heaviest respondent is a woman aged between 30 and 44, weighing 162kg. The second is a woman aged between 5 and 14 years old. The arranging is independent from the grouping. 

::: key-point
Now let's arrange by groups by adding the argument `.by_group=TRUE`. 
:::

```{r, message = F, render = reactable_10_rows}
yao %>%
  select(age_category, sex, weight_kg) %>%
  group_by(age_category, sex) %>%
  arrange(desc(weight_kg), .by_group=TRUE)
```
We can see that now the arranging is done per group. Per group, the respondents are presented from heaviest to lightest. The first group is composed of girls that are 5 to 14 years old. The heaviest is 161kg. Then the next group consists of the boys aged from 5 to 14 years old, where the heaviest respondent is 99kg. And so on and so forth for different combinations of age categories and genders. 

::: recap

You can arrange **regardless** of groups by apply `group_by(___) %>% arrange(___)`.

You can arrange **in function of groups** by including an setting a parameter to `TRUE` within arrange: `group_by(___) %>% arrange(___, .by_group=TRUE)`.

:::

::: practice
With the `sarcopenia` data, select socioeconomic class (`r socioeconomic_class`), gender (`r sex_male_1_female_0`), and gait speed (`r gait_speed_meters_per_second`). 

Then group by socioeconomic class and gender, and arrange the resulting data frame by gait speed to see the fastest gait speed first. 

```{r eval = FALSE}
# Complete the code with your answer:
Q_gait_speed_arranged <- 
  sarcopenia %>% 
  select(______________________________) %>%
  group_by(______________________________) %>%
  arrange(______________________________)
```

```{r include = FALSE}
# Check your answer
.CHECK_Q_gait_speed_arranged()
.HINT_Q_gait_speed_arranged()
```
:::

## Groupings' effect on `mutate()`

`mutate()` is used to modify in place columns or to create new variables. 

Without groupings, `mutate()` applies itself over the entire variable (i.e. column). With groupings, `mutate()` operates over each group within the variable. 

Let's compare with and without groupings. 

We will look at the difference in calculating the standard weight in the `yao` data frame, depending on if we have grouped our data by IgG results or not.

First we shall looked at ungrouped data. We will select the columns of interest, IgG results and weight, then summarize the weight data into its mean.

```{r, message = F, render = reactable_10_rows}
yao %>%
  select(igg_result, weight_kg) %>%
  summarize(mean_weight = mean(weight_kg, na.rm=TRUE))
```
We obtain a single mean for the entire weight variable. Then we proceed to using this mean to calculate the standard weight.

```{r, message = F, render = reactable_10_rows}
yao %>%
  select(igg_result, weight_kg) %>%
  mutate(standard_weight = weight_kg - mean(weight_kg, na.rm=TRUE))
```
The resulting data frame shows us that the standard weight variable has been created, with each respondent's weight subtracted of 64.4kg (the mean weight). 

Now let's see what changes when we do the same operation while grouping our data into IgG results groups. The IgG results variable has two possible values (`"Negative"` and `"Positive"`) hence it has two groups. 

```{r, message = F, render = reactable_10_rows}
yao %>%
  select(igg_result, weight_kg) %>%
  group_by(igg_result) %>%
  summarize(mean_weight = mean(weight_kg, na.rm=TRUE))
```
When summarizing to look at the mean weight, we now observe that two mean weights have been calculated: one per group. The mean weight over respondents with a positive IgG result is of 66.9kg, while it is of 63.3kg for respondents with a negative result.

Let's look at how this impacts `mutate()`:

```{r, message = F, render = reactable_10_rows}
yao %>%
  select(igg_result, weight_kg) %>%
  group_by(igg_result) %>%
  mutate(standard_weight = weight_kg - mean(weight_kg, na.rm=TRUE))
```
Now, when we subtract the mean weight from the weight variable to create the standard weight variable, the mean weight subtracted will depend on the group. For our first data entry, with negative IgG result, his 95kg weight will be subtracted of 63.3kg because this is the mean weight of the IgG negative results group. In contrast, the second data entry, who has a positive IgG result, has his weight of 96kg subtracted of 66.9kg, the average for the positive IgG group. 

The operations of `mutate()` are now group dependent. 

::: recap

Applying `mutate()` on **ungrouped** data will apply the manipulation over the entire variable.

Calling `mutate()` on **grouped** data will apply the transformation independently and respectively to each group present within that variable.

:::

::: practice
With the `sarcopenia` data, select age (`r age`), gender (`r sex_male_1_female_0`), and grip strength (`r grip_strength_kg`). 

Then group by age and gender and calculate **by groups** the standard grip strength (i.e. subtracting the mean grip strength).

```{r eval = FALSE}
# Complete the code with your answer:
Q_standard_mean_grip_strength <- 
  sarcopenia %>% 
  select(______________________________) %>%
  group_by(______________________________) %>%
  mutate(______________________________)
```

```{r include = FALSE}
# Check your answer
.CHECK_Q_standard_mean_grip_strength()
.HINT_Q_standard_mean_grip_strength()
```
:::

## Groupings' effect on `filter()`

`filter()` keeps or drops certain rows based on a condition, over an entire variable. 

Similar to `mutate()` if `filter()` is applied to a grouped data set then the filtering operation will be carried out in parallel for each group.

Let's illustrate this by looking into keep the maximal weight over different data settings (ungrouped, grouped, grouped in a nested manner).

For each, we will select the age category variable, the IgG results, and the weight variable.

We begin with ungrouped data. We obtain the maximal weight by setting the condition `weight_kg == max(weight_kg)` inside the filtering. 

```{r, message = F, render = reactable_10_rows}
yao %>%
  select(igg_result, age_category, weight_kg) %>%
  filter(weight_kg == max(weight_kg)) %>%
  arrange(igg_result, age_category)
```
Our resulting data frame is composed of 1 row: the maximal weight over all respondents: 162kg for a person aged between 30 and 44, tested IgG positive. 

Now, let's introduce a grouping by IgG results and let's see what happens.

```{r, message = F, render = reactable_10_rows}
yao %>%
  select(igg_result, age_category, weight_kg) %>%
  #We have now introduced a grouping !
  group_by(igg_result) %>%
  filter(weight_kg == max(weight_kg)) %>%
  arrange(igg_result, age_category)
```
Now when we filter for the maximal weight, we get 2 rows: the maximal weight for the IgG positive group (162kg) and the maximal weight for the IgG negative group (161kg). Since we also selected the age category variable, we know how old they are. 

Now let's see how the filtering works if we want to also group by the age category in addition to the IgG results. 

```{r, message = F, render = reactable_10_rows}
yao %>%
  select(igg_result, age_category, weight_kg) %>%
  # Now we are performing a nested grouping !
  group_by(igg_result, age_category) %>%
  filter(weight_kg == max(weight_kg)) %>%
  arrange(igg_result, age_category)
```

We have an output of 10 rows: 

`2 groups for the IgG results x 5 groups for the age categories = 10 unique groupins`

For each of these groups, we get the maximal weight of their respondents: overall all respondents IgG negative, aged between 45 and 64 years old, the maximal weight was of 158kg. 

We decided to `arrange()` the results by IgG results then age category, but we could do the contrary to contrast negative and positive results by age category. See below:

```{r, message = F, render = reactable_10_rows}
yao %>%
  select(igg_result, age_category, weight_kg) %>%
  group_by(igg_result, age_category) %>%
  filter(weight_kg == max(weight_kg)) %>%
  # Our arrangement has changed
  arrange(age_category, igg_result)
```

With this arrangement, we have an easier overview, per age category, who is heavier between the those tested IgG positive vs. those tested IgG negative. 

::: practice
With the `sarcopenia` data, select age (`r age`), gender (`r sex_male_1_female_0`), socioeconomic class (`r socioeconomic_class`) and skeletal muscle index (`r skeletal_muscle_index`). Group by age, gender and socioeconomic class, then filter for the max of each group. 

```{r eval = FALSE}
# Complete the code with your answer:
Q_max_skeletal_muscle_index <- 
  sarcopenia %>% 
  select(______________________________) %>%
  group_by(______________________________) %>%
  filter(______________________________)
```

```{r include = FALSE}
# Check your answer
.CHECK_Q_max_skeletal_muscle_index()
.HINT_Q_max_skeletal_muscle_index()
```
:::

Let's do another example of filtering using the `tally()` verb. The `tally()` verb allows us to quickly assess how many individuals we have in subgroups of our data. 

::: key-point
For further analysis, you should always consider having sufficient data (i.e. a sufficient number of respondents in this case) to do statistical analysis. 

Hence it can be useful to make your groups using `group_by()` and then quickly overview if they are populated enough to conduct an analysis on them. 
:::

We will see an example of this subgroup selection by grouping the `yao` data frame by occupation and gender. We then apply `tally()` to know how many respondents fall into each group of occupation + gender. 

```{r, message = F, render = reactable_10_rows}
yao %>%
  select(occupation, sex) %>%
  group_by(occupation, sex) %>%
  tally() %>%
  arrange(n)
```
We observe that for many combinations, we only have one individual of that gender having that occupation. If we wanted to make subgroups to investigate further into this stratification by gender and occupation, we would not want to have this 1 person groups. Let's see how to leave them aside using `filter()` and a condition such as `n() > 50` (the condition translates to: keep only groups with more than 50 respondents).
```{r, message = F, render = reactable_10_rows}
yao %>%
  select(occupation, sex) %>%
  group_by(occupation, sex) %>%
  filter(n() > 50) 
```

This gives us all the rows (i.e. respondents) who correspond to a combination occupation + gender having more than 50 respondents. If we want to see the total of respondents per group, we apply `tally()` once again:

```{r, message = F, render = reactable_10_rows}
yao %>%
  select(occupation, sex) %>%
  group_by(occupation, sex) %>%
  filter(n() > 50) %>% 
  tally()
```
Now we only have 6 rows, 6 unique combinations of occupation + gender, which have more than 50 respondents. For further analysis of these combinations, we could compare the 77 female informal workers to the 112 male informal workers, OR we could compare the 203 female students to the 180 male students. 

::: practice
With the `sarcopenia` data, select and group by marital status (`r maritual_status`) and gender (`r sex_male_1_female_0`). And filter for groups of more than 20 individuals.

```{r eval = FALSE}
# Complete the code with your answer:
Q_marital_status_gender_20_individuals <- 
  sarcopenia %>% 
  select(______________________________) %>%
  group_by(______________________________) %>%
  filter(______________________________)
```

```{r include = FALSE}
# Check your answer
.CHECK_Q_marital_status_gender_20_individuals()
.HINT_Q_marital_status_gender_20_individuals()
```
:::

## Wrap up

`group_by()` is a marvelous tool for arranging, mutating, filtering based on the groups within a single or multiple variables. 


![Fig: arrange() and group_by()](images/custom_dplyr_groupby_arrange.png){alt="Fig: arrange() and its use combined with group_by()." width="400"}
![Fig: mutate() and group_by()](images/custom_dplyr_groupby_mutate.png){alt="Fig: mutate() and its use combined with group_by()." width="400"}
![Fig: filter() and group_by()](images/custom_dplyr_groupby_filter.png){alt="Fig: filter() and its use combined with group_by()." width="400"}

However, once grouped, the data set remains grouped. It is of utmost importance to remember to `ungroup` once your operations on the groups are done. 

There are numerous other manners of combining these verbs to manipulate your data and I invite you to take a while and try it out! 

See you next time!

## Contributors {.unlisted .unnumbered}

The following team members contributed to this lesson:

`r tgc_contributors_list(ids = c("lolovanco", "kendavidn"))`

## References {.unlisted .unnumbered}

Some material in this lesson was adapted from the following sources:

-   Horst, A. (2022). *Dplyr-learnr*. <https://github.com/allisonhorst/dplyr-learnr> (Original work published 2020)

-   *Create, modify, and delete columns --- Mutate*. (n.d.). Retrieved 21 February 2022, from <https://dplyr.tidyverse.org/reference/mutate.html>

-   *Apply a function (or functions) across multiple columns --- Across*. (n.d.). Retrieved 21 February 2022, from <https://dplyr.tidyverse.org/reference/across.html>

Artwork was adapted from:

-   Horst, A. (2022). *R & stats illustrations by Allison Horst*. <https://github.com/allisonhorst/stats-illustrations> (Original work published 2018)
