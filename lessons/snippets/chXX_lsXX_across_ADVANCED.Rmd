---
title: '\ '
output:
  # word_document:
  #   toc: yes
  html_document:
    number_sections: yes
    toc: yes
    css: !expr here::here("global/style/style.css")
    highlight: kate
    pandoc_args: --shift-heading-level-by=-1
editor_options:
  markdown:
    wrap: 100
always_allow_html: yes
---

```{r, echo = F, message = F, warning = F}
library(tidyverse)
library(knitr)

## functions
source(here::here("global/functions/misc_functions.R"))

## default render
registerS3method("reactable_5_rows", "data.frame", reactable_5_rows)
knitr::opts_chunk$set(class.source = "tgc-code-block", render = reactable_5_rows)

## autograders
suppressMessages(source(here::here("lessons/ls05_across_autograder.R")))
```


Now, let's see some other situation where you may want to write your own custom function.

Imagine you want to normalize the heights and weights of the different participants to use this data for further statistical analysis.

Imagine that you want the values of the distribution `X` to be in a 0-1 range: you want to make your own min-max normalization function of each element `x` of the distribution `X`.

$$
x_{normalized} = \frac{x - min(X)}{max(X) - min(X)}
$$

```{r}
yao %>%
  mutate(across(c("height_m", "weight_kg"), 
                ~ (.x - min(.x)) / (max(.x) - min(.x)) , 
                .names = "normalized_{.col}"),
         .keep="unused") 
```

::: practice
Now let's normalize the height (in meters), the weight and the age using a mean-standard deviation normalization.

Set the argument `.keep` to `unused` and name the new columns using the `.names` argument as above (`.names = "mean_std_normalization_{.col}"`).

The formula consists in normalizing element `x` of distribution `X` using the mean and standard deviation of `X` as follows:

$$
x_{normalized} = \frac{x-mean(X)}{std(X)}
$$

```{r, eval = F, echo=FALSE}
q5 <- "YOUR_ANSWER_HERE"
.check_q5()
.hint_q5()
```
:::

## Mixing custom and predefined functions to transform "across" multiple columns

::: challenge
**Just a heads up ! This is next level**: so look into it, inspire yourself, but it's alright if it appears too complex. Also, maybe this code can be useful for your projects, feel free to copy-paste.
:::

You can also mix-match between your custom function and predefined functions. Such an example would be to use `dplyr::case_when()` **across** multiple columns.

Imagine that you want to remove the `NA` from your categorical variables (let's use `is.character()`), and set them to `Unknown`. For all none `NA` entries, you want to keep the existing value (referenced by `.x` as explained in the Key Point above).

```{r, eval = F}
yao %>% 
  mutate(
    across(where(is.character), 
           ~case_when(is.na(.x) ~"Unknown", 
                      !is.na(.x) ~ .x) , 
                .names = "unk_{.col}"),
         .keep="used") %>% 
  count(is_smoker,unk_is_smoker)
```


