---
title: 'Other grouped operations'
output:
  html_document:
    number_sections: true
    toc: true
    toc_float: true
    css: !expr here::here("global/style/style.css")
    highlight: kate
---

```{r, eval = F, include = F}
Hi GRAPH Courses student!
  
This is a CODE ALONG document where you can type code as you follow the lesson video. 

We encourage you to do this; typing code with the teacher is the best way to learn the right syntax. 

If you are not sure how to use our code-along documents, please watch this video: https://vimeo.com/767363677
```

```{r, echo = F, message = F, warning = F}
if(!require(pacman)) install.packages("pacman")
pacman::p_load(knitr, 
               here, 
               janitor,
               tidyverse)

## functions
source(here::here("global/functions/misc_functions.R"))

## default render
knitr::opts_chunk$set(warning = F, message = F, class.source = "tgc-code-block", error = T)

## autograders
suppressMessages(source(here::here("autograder/ls06_group_by_other_verbs_autograder.R")))
```

## Learning objectives

1.  You can use `group_by()` with `arrange()`, `filter()`, and `mutate()` to conduct grouped operations on a data frame.

## Packages

This lesson will require the {tidyverse} suite of packages and the {here} package:

```{r}
if(!require(pacman)) install.packages("pacman")
pacman::p_load(tidyverse, here)
```

## Datasets

The COVID-19 serological survey conducted in Yaounde, Cameroon !

```{r, message = F}
yao <- 
  read_csv(here::here('data/yaounde_data.csv'))  %>% 
  select(sex, age, age_category, weight_kg, occupation, igg_result, igm_result) %>%
  rename(age_years = age)

yao

yao_sex_weight <- 
  yao %>% 
  select(____________________)

yao_sex_weight
```

------------------------------------------------------------------------

For practice questions: the sarcopenia data set.

```{r, message = F}
sarcopenia <- read_csv(here::here('data/sarcopenia_elderly.csv'))

sarcopenia
```

## Arranging by group

-   Reminder: `arrange()` orders the rows of a data frame by the values of selected columns.

-   Sensitive to groupings IF `.by_group` is set to `TRUE`

```{r}
yao_sex_weight
```

We can arrange this data frame **by weight** like so:

```{r}
yao_sex_weight %>% ____________________
```

As expected, **lower weights** have been brought to **the top of the data frame**.

If we first group the data, we could expect a different output:

```{r}
yao_sex_weight %>% 
  ____________________
  ____________________
```

But as you see, the **arrangement is still the same**.

Only when we set the `.by_group` argument to `TRUE` do we get something different:

```{r}
yao_sex_weight %>% 
  ____________________
  ____________________
```

The data is *first* sorted by sex (all women first), and then by weight.

### `arrange()` can group automatically

-   We do not need `group_by()` to arrange by group!

-   We can simply put multiple variables in the `arrange()` function.

```{r}
yao_sex_weight %>% 
  ____________________________
```

The code `arrange(sex, weight_kg)` tells R to arrange the rows *first* by sex, and then by weight.

It is equivalent to the more complex `group_by()`, `arrange()` statement used before:

```{r eval = F}
yao_sex_weight %>% 
  group_by(sex) %>% 
  arrange(weight_kg, .by_group = TRUE)
```

Obviously, the syntax, with no `group_by()` is simpler, so let's stick to that !

::: Reminder
`desc()` **for descending order**

To arrange *in descending order*, we can wrap the target variable in `desc()`.

To sort by sex and weight, with the heaviest people on top, we can write:

```{r}
yao_sex_weight %>% 
  ___________________________
```
:::

::: practice
With an `arrange()` call, sort the `sarcopenia` data first by sex and then by grip strength. (If done correctly, the first row should be of a woman with a grip strength of 1.3 kg). To make the arrangement clear, you should first `select()` the sex and grip strength variables (in that order).

```{r eval = FALSE}
# Complete the code with your answer:
Q_grip_strength_arranged <- 
  sarcopenia %>% 
  select(______________________________) %>% 
  arrange(______________________________)
```

```{r include = FALSE}
# Check your answer
.CHECK_Q_grip_strength_arranged()
.HINT_Q_grip_strength_arranged()

# To get the solution, run the line below
.SOLUTION_Q_grip_strength_arranged()
# Each question has a solution function similar to this.
# Where HINT is replaced with SOLUTION in the function name.
# But you will need to type out the function name for the remaining solutions on your own.
# This is to discourage you from looking at the solution before answering the question.
```

:::

::: practice
The `sarcopenia` dataset contains a column, `age_group`, which stores age groups as a string (the age groups are "Sixties", "Seventies" and "Eighties"). Convert this variable to a factor with the levels in the right order (first "Sixties" then "Seventies" then "Eighties"). (Hint: Look back on the `case_when()` lesson if you do not see how to relevel a factor.)

Then, with a nested `arrange()` call, arrange the data first by the newly-created `age_group` factor variable (younger individuals first) and then by `height_meters`, with shorter individuals first.

```{r eval = FALSE}
# Complete the code with your answer:
Q_age_group_height <- 
  sarcopenia 
```

```{r include = FALSE}
# Check your answer
.CHECK_Q_age_group_height()
.HINT_Q_age_group_height()
```
:::

## Filtering by group

-   Reminder: `filter()` keeps or drops rows based on a condition.

-   If `filter()` is applied to grouped data, the filtering operation is carried out separately for each group.

If we want to filter the data for the heaviest person, we could run:

```{r}
yao_sex_weight %>% 
  __________________________
```

-   What if we want the heaviest man *and* the heaviest woman?

-   We want the maximal weight per gender group !

```{r}
yao_sex_weight %>% 
  __________________________
  __________________________
```

The code above can be read as "For each sex group, keep the row with the maximum `weight_kg` value".

### Filtering with nested groupings

For example, if we want to see the heaviest man and heaviest woman *per age group* :

```{r}
yao %>% 
  group_by(__________________________) %>% 
  filter(weight_kg == max(weight_kg))
```

(Why do we have 10 rows in the output? Well, 2 sex groups x 5 groups age groups = 10 unique groupings.)

The output is a bit scattered: let's use `arrange()` to rearrange by sex and age group.

```{r}
yao %>% 
  group_by(sex, age_category) %>% 
  filter(weight_kg == max(weight_kg)) %>% 
  arrange(_________________________)
```

-   But we notice a weird arrangement of the age groups!

-   Those aged 5 to 14 should come *first* in the arrangement.

-   Of course, we've learned how to fix this:

```{r}
yao %>%
  mutate(age_category = __________________________________________) %>%
  group_by(sex, age_category) %>%
  filter(weight_kg == max(weight_kg)) %>%
  arrange(sex, age_category)
```

Now we have a nice and well-arranged output!

::: practice
Group the `sarcopenia` data frame by age group and sex, then filter for the highest skeletal muscle index in each (nested) group.

```{r eval = FALSE}
# Complete the code with your answer:
Q_max_skeletal_muscle_index <- 
  sarcopenia 
```

```{r include = FALSE}
# Check your answer
.CHECK_Q_max_skeletal_muscle_index()
.HINT_Q_max_skeletal_muscle_index()
```
:::

## Mutating by group

-   Reminder: `mutate()` is used to modify columns or to create new ones.

-   With grouped data, `mutate()` operates over each group independently.

Let's first consider a regular `mutate()` call. Imagine that you wanted to add a column that ranks respondents by weight:

```{r}
yao_sex_weight %>% 
  _______________________________
```

The output shows that the first row is the 901st lightest individual.

But it would be more intuitive to rank in descending order with the heaviest person first:

```{r}
yao_sex_weight %>% 
  mutate(_______________________________)
```

The output shows that the person in the first row is the 71st heaviest individual.

------------------------------------------------------------------------

-   Now, let's try to write a grouped `mutate()` call.

-   We want to add this weight rank column *per sex group* in the data frame.

-   We want to know each person's weight rank in their sex category.

```{r}
yao_sex_weight %>% 
  _______________________
  ______________________________________________
```

Now we see that the person in the first row is the 53rd heaviest *woman*. (The .5 indicates that this rank is a tie with someone else in the data.)

We could also arrange for clarity:

```{r}
yao_sex_weight %>% 
  group_by(sex) %>% 
  mutate(weight_rank = rank(desc(weight_kg))) %>% 
  _______________________
```

### Mutating with nested groupings

```{r}
yao %>% 
  # let's group by sex and age category now !
  group_by(_______________________) %>% 
  mutate(weight_rank = rank(desc(weight_kg)))
```

The output shows that the person in the first row is 20th heaviest *woman in the 45 to 64 age group*.

::: practice
With the `sarcopenia` data, group by `age_group`, then in a new variable called `grip_strength_rank`, compute the per-age-group rank of each individual's grip strength. (To compute the rank, use `mutate()` and the `rank()` function with its default ties method.)

```{r eval = FALSE}
# Complete the code with your answer:
Q_rank_grip_strength <- 
  sarcopenia
```

```{r include = FALSE}
# Check your answer
.CHECK_Q_rank_grip_strength()
.HINT_Q_rank_grip_strength()
```
:::

::: watch-out
**Remember to ungroup data before further analysis**

-   It is SUPER important ungroup your data before doing further analysis.

Let's start off from the previous example:

```{r}
yao_modified <- yao %>% 
  group_by(sex, age_category) %>% 
  mutate(weight_rank = rank(desc(weight_kg)))
```

And now, you want to **filter** to get **the oldest person** in the data:

```{r}
yao_modified %>% 
  _____________________________
```

-   You might be confused by the output! Why are there 55 rows of "oldest people"?

-   Because there is one oldest person by subgroup defined by sex and age categories combinations !

-   Because we forgot to ungroup !

Let's do this properly now:

```{r}
yao_modified <- 
  yao %>% 
  group_by(sex, age_category) %>% 
  mutate(weight_rank = rank(desc(weight_kg))) %>% 
  _______________________
```

Now we can correctly obtain the oldest person/people in the data set:

```{r}
yao_modified %>% 
  _______________________
```
:::

## Wrap up

`group_by()` is a marvelous tool for arranging, mutating, filtering based on the groups within a single or multiple variables.

![Fig: arrange() and group_by()](images/custom_dplyr_groupby_arrange.png){alt="Fig: arrange() and its use combined with group_by()." width="400"} ![Fig: mutate() and group_by()](images/custom_dplyr_groupby_mutate.png){alt="Fig: mutate() and its use combined with group_by()." width="400"}

![Fig: filter() and group_by()](images/custom_dplyr_groupby_filter.png){alt="Fig: filter() and its use combined with group_by()." width="400"}

There are numerous ways of combining these verbs to manipulate your data. We invite you to take some time and to try these verbs out in different combinations!

See you next time!


## References {.unlisted .unnumbered}

Some material in this lesson was adapted from the following sources:

-   Horst, A. (2022). *Dplyr-learnr*. <https://github.com/allisonhorst/dplyr-learnr> (Original work published 2020)

-   *Create, modify, and delete columns --- Mutate*. (n.d.). Retrieved 21 February 2022, from <https://dplyr.tidyverse.org/reference/mutate.html>

-   *Apply a function (or functions) across multiple columns --- Across*. (n.d.). Retrieved 21 February 2022, from <https://dplyr.tidyverse.org/reference/across.html>

Artwork was adapted from:

-   Horst, A. (2022). *R & stats illustrations by Allison Horst*. <https://github.com/allisonhorst/stats-illustrations> (Original work published 2018)
