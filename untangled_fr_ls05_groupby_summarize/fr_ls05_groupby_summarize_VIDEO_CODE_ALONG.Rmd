---
title: 'Notes de le√ßon | Regroupement et r√©sum√© des donn√©es'
output:
  html_document:
    number_sections: true
    toc: true
    toc_float: true
    css: !expr here::here("global/style/style.css")
    highlight: kate
editor_options: 
  chunk_output_type: console
---

```{r, echo = F, message = F, warning = F}
library(tidyverse)
library(knitr)

## fonctions
source(here::here("global/functions/misc_functions.R"))

## rendu par d√©faut
knitr::opts_chunk$set(class.source = "tgc-code-block", render = normal_print)

```

# Introduction

Vous savez d√©j√† comment conserver les jeux donn√©es qui vous int√©ressent, comment garder les variables pertinentes et comment les modifier ou en cr√©er de nouvelles.

Maintenant, nous allons aller un peu plus loin dans la manipulation de vos donn√©es en comprenant comment extraire facilement des statistiques r√©capitulatives, gr√¢ce au verbe `summarize()`, comme le calcul de la moyenne d'une variable.

De plus, nous commencerons √† explorer un verbe crucial, `group_by()`, capable de regrouper vos variables ensemble pour effectuer des op√©rations group√©es sur votre jeu de donn√©es.

Allons-y !

------------------------------------------------------------------------

# Objectifs d'apprentissage

1.  Vous pouvez utiliser `dplyr::summarize()` pour extraire des statistiques r√©capitulatives des jeux de donn√©es.

2.  Vous pouvez utiliser `dplyr::group_by()` pour regrouper les donn√©es par une ou plusieurs variables avant d'effectuer des op√©rations sur elles.

3.  Vous comprenez pourquoi et comment d√©grouper les jeux de donn√©es group√©s.

4.  Vous pouvez utiliser `dplyr::n()` avec `group_by()`-`summarize()` pour compter les lignes par groupe.

5.  Vous pouvez utiliser `sum()` avec `group_by()`-`summarize()` pour compter les lignes qui r√©pondent √† une condition.

6.  Vous pouvez utiliser `dplyr::count()` comme une fonction pratique pour compter les lignes par groupe.

------------------------------------------------------------------------

# Le jeu de donn√©es COVID-19 de Yaound√©

Dans cette le√ßon, nous allons √† nouveau utiliser les donn√©es de l'enqu√™te s√©rologique COVID-19 men√©e √† Yaound√©, au Cameroun.

```{r, message = F}
yaounde <- read_csv(here::here('data/fr_yaounde_data.csv'))

# Un sous-ensemble plus petit de variables
yao <- yaounde %>% select(
  age, cat_age_3, sexe, poids_kg, taille_cm,
  quartier, fumeur, enceinte, occupation,
  combinaisons_traitement, symptomes, jours_absence_travail, jours_alite,
  edu_haute, resultat_igg)

yao
```

Consultez la premi√®re le√ßon de ce chapitre pour plus d'informations sur ce jeu de donn√©es.

# Qu'est-ce qu'une statistique r√©capitulative ?

Une statistique r√©capitulative est une valeur unique (telle qu'une moyenne ou une m√©diane) qui d√©crit une s√©quence de valeurs (g√©n√©ralement une colonne dans votre jeu de donn√©es).

![](images/fr_what_is_a_summary_statistic.png){width="363"}

Les statistiques r√©capitulatives peuvent d√©crire le centre, la dispersion ou l'√©tendu d'une variable, ou les nombres et les positions des valeurs au sein de cette variable. Certaines statistiques r√©capitulatives courantes sont pr√©sent√©es dans le diagramme ci-dessous :

![](images/fr_summary_stats_examples.png){width="495"}

Le calcul des statistiques r√©capitulatives est une op√©ration tr√®s courante dans la plupart des processus d'analyse de donn√©es, il sera donc important de devenir comp√©tent pour les extraire de vos jeux de donn√©es. Et pour cette t√¢che, il n'y a pas de meilleur outil que la fonction `summarize()` de {dplyr} ! Alors voyons comment utiliser cette puissante fonction.

# Introduction √† `dplyr::summarize()`

Pour commencer, il est pr√©f√©rable de voir d'abord comment obtenir des statistiques r√©capitulatives simples *sans* utiliser `summarize()`, puis nous verrons pourquoi vous devriez *r√©ellement* utiliser `summarize()`.

Imaginez que l'on vous demande de trouver l'√¢ge moyen des r√©pondants dans le jeu de donn√©es `yao`. Comment pourriez-vous le faire en R de base ?

Tout d'abord, rappelons que la fonction du signe dollar, `$`, vous permet d'extraire une colonne d'un jeu de donn√©es vers un vecteur :

```{r eval = F}
yao$age # extraire la colonne `age` de `yao`
```

Pour obtenir la moyenne, vous passez simplement ce vecteur `yao$age` dans la fonction `mean()` :

```{r}
mean(yao$age)
```

Et c'est tout ! Vous avez maintenant une statistique r√©capitulative simple. Extr√™mement facile, n'est-ce pas ?

Alors, pourquoi avons-nous besoin de `summarize()` pour obtenir des statistiques r√©capitulatives si le processus est d√©j√† si simple sans lui ? Nous reviendrons sur la question du *pourquoi* bient√¥t. D'abord, voyons *comment* obtenir des statistiques r√©capitulatives avec `summarize()`.

En revenant √† l'exemple pr√©c√©dent, la syntaxe correcte pour obtenir l'√¢ge moyen avec `summarize()` serait :

```{r}
yao %>% 
  summarize(mean_age = mean(age))
```

L'anatomie de cette syntaxe est pr√©sent√©e ci-dessous. Vous devez simplement entrer le nom de la nouvelle colonne (par exemple `mean_age`), la fonction r√©capitulative (par exemple `mean()`), et la colonne √† r√©sumer (par exemple `age`).

![*Fig.* Syntaxe de base pour la fonction `summarize()`.](images/fr_summarize_syntax.png)

------------------------------------------------------------------------

Vous pouvez √©galement calculer plusieurs statistiques r√©capitulatives dans une seule commande `summarize()`. Par exemple, si vous vouliez √† la fois l'√¢ge moyen et l'√¢ge m√©dian, vous pourriez ex√©cuter :

```{r}
yao %>% 
  summarize(mean_age = mean(age), 
            median_age = median(age))
```

Sympa !

------------------------------------------------------------------------

Maintenant, vous devriez vous demander pourquoi `summarize()` place les statistiques r√©capitulatives dans un jeu de donn√©es, avec chaque statistique dans une colonne diff√©rente.

Le principal avantage de cette structure de jeu de donn√©es est de faciliter la production de r√©sum√©s *group√©s* (et la cr√©ation de tels r√©sum√©s group√©s sera le principal avantage de l'utilisation de `summarize()`).

Nous examinerons ces r√©sum√©s group√©s dans la section suivante. Pour l'instant, essayez de r√©pondre aux questions de pratique ci-dessous.

::: practice
**Pratique 1**

Utilisez `summarize()` et les fonctions r√©capitulatives pertinentes pour obtenir la moyenne, la m√©diane et l'√©cart type des poids des r√©pondants √† partir de la variable `poids_kg` du jeu de donn√©es `yao`.

Votre sortie doit √™tre un jeu de donn√©es avec trois colonnes nomm√©es comme indiqu√© ci-dessous :

| mean_poids_kg | median_poids_kg | sd_poids_kg |
|---------------|-----------------|-------------|
|               |                 |             |

*Note : Les solutions de tous les exercices pratiques se trouvent √† la fin de ce document.*

```{r, eval = FALSE}

  yao %>%
  ____________________________
```
:::

::: practice
**Pratique 2**

Utilisez `summarize()` et les fonctions r√©capitulatives pertinentes pour obtenir les tailles minimale et maximale des r√©pondants √† partir de la variable `taille_cm` du jeu de donn√©es `yao`.

Votre sortie doit √™tre un jeu de donn√©es avec deux colonnes nomm√©es comme indiqu√© ci-dessous :

| min_taille_cm | max_taille_cm |
|---------------|---------------|
|               |               |

```{r, eval = FALSE}

  yao %>% 
  ____________________________
```
:::

# R√©sum√©s group√©s avec `dplyr::group_by()`

Comme son nom l'indique, `dplyr::group_by()` vous permet de regrouper un jeu de donn√©es par les valeurs d'une variable (par exemple le sexe masculin vs f√©minin). Vous pouvez ensuite effectuer des op√©rations qui sont divis√©es selon ces groupes.

Quel effet `group_by()` a-t-il sur un jeu de donn√©es ? Essayons de regrouper le jeu de donn√©es `yao` par sexe et observons l'effet :

```{r}
yao %>% 
  group_by(sexe)
```

Hmm. Apparemment, rien ne s'est pass√©. La seule chose que vous *pourriez* remarquer est une nouvelle section dans l'en-t√™te qui vous indique la variable group√©e---sex---et le nombre de groupes---2 :

```         
    # A tibble: 971 √ó 10
  üëâ# Groups:   sexe [2]üëà
```

Mis √† part cet en-t√™te, cependant, le jeu de donn√©es semble inchang√©.

Mais voyez ce qui se passe lorsque nous cha√Ænons le `group_by()` avec l'appel `summarize()` que nous avons utilis√© dans la section pr√©c√©dente :

```{r}
yao %>% 
  group_by(sexe) %>% 
  summarize(mean_age = mean(age))
```

Vous obtenez une statistique r√©capitulative diff√©rente pour chaque groupe ! Les statistiques pour les femmes sont dans une ligne et celles pour les hommes sont dans une autre. (√Ä partir de ce jeu de donn√©es de sortie, vous pouvez dire par exemple que, l'√¢ge moyen pour les r√©pondantes est de 29.5, tandis que pour les r√©pondants masculins, il est de 28.4)

Comme mentionn√© pr√©c√©demment, ce type de r√©sum√© group√© est la raison principale pour laquelle la fonction `summarize()` est si utile !

------------------------------------------------------------------------

Voyons un autre exemple d'une op√©ration simple `group_by()` + `summarize()`.

Supposons que l'on vous ait demand√© d'obtenir les poids maximum et minimum pour les individus dans diff√©rents quartiers dans le jeu de donn√©es `yao`. D'abord, vous feriez un `group_by()` sur la variable `neighbourhood`, puis vous appeleriez les fonctions `max()` et `min()` √† l'int√©rieur de `summarize()` :

```{r}
yao %>% 
  group_by(quartier) %>% 
  summarize(max_poids = max(poids_kg), 
            min_poids = min(poids_kg))
```

Super ! Avec seulement quelques lignes de code, vous √™tes capable d'extraire beaucoup d'informations.

------------------------------------------------------------------------

Voyons encore un exemple pour faire bonne mesure. La variable `jours_absence_travail` nous indique le nombre de jours o√π les r√©pondants ont √©t√© absents au travail en raison de sympt√¥mes similaires √† ceux du COVID. Les individus qui n'ont signal√© aucun sympt√¥me semblable √† celui du COVID ont un `NA` pour cette variable :

```{r}
yao %>% 
  select(jours_absence_travail)
```

Pour compter le nombre total de jours de travail manqu√©s pour chaque groupe de sexe, vous pourriez essayer d'ex√©cuter la fonction `sum()` sur la variable `jours_absence_travail` :

```{r}
yao %>% 
  group_by(sexe) %>% 
  summarise(total_jours_absence = sum(jours_absence_travail))
```

Hmmm. Cela vous donne des r√©sultats `NA` car certaines lignes dans la colonne `jours_absence_travail` ont des `NA` en elles, et R ne peut pas trouver la somme de valeurs contenant un `NA`. Pour r√©soudre ce probl√®me, l'argument `na.rm = TRUE` est n√©cessaire :

```{r}
yao %>% 
  group_by(sexe) %>% 
  summarise(total_jours_absence = sum(jours_absence_travail, na.rm = TRUE))
```

La sortie nous dit qu'au total, parmi toutes les femmes de l'√©chantillon, 256 jours de travail ont √©t√© manqu√©s en raison de sympt√¥mes similaires √† ceux du COVID, et parmi tous les hommes, 272 jours.

------------------------------------------------------------------------

J'esp√®re que vous voyez maintenant pourquoi `summarize()` est si puissant. En combinaison avec `group_by()`, il vous permet d'obtenir des r√©sum√©s de vos jeux de donn√©es group√©s tr√®s informatifs avec tr√®s peu de lignes de code.

Produire de tels r√©sum√©s est une partie tr√®s importante de la plupart des processus d'analyse de donn√©es, cette comp√©tence sera donc probablement utile tr√®s prochainement !

::: vocab
**`summarize()` produit des "Tableaux crois√©s dynamiques"**

Les jeux de donn√©es r√©capitulatifs cr√©√©s par `summarize()` sont souvent appel√©s des tableaux crois√©s dynamiques dans le contexte des logiciels de tableur comme Microsoft Excel.
:::

::: practice
**Pratique 3**

Utilisez `group_by()` et `summarize()` pour obtenir le poids moyen (kg) en fonction du statut de fumeur dans le jeu de donn√©es `yao`. Nommez la colonne de poids moyen `poids_moyen`

Le jeu de donn√©es de sortie doit ressembler √† ceci :

| fumeur     | poids_moyen |
|------------|-------------|
| Ex-fumeur  |             |
| Non-fumeur |             |
| Fumeur     |             |
| NA         |             |

```{r eval = FALSE}
 
  yao %>% 
  ________________________
  ________________________
```
:::

::: practice
**Pratique 4**

Utilisez `group_by()`, `summarize()` et les fonctions de statistiques r√©capitulatives pertinentes pour obtenir les tailles minimum et maximum pour chaque sexe dans le jeu de donn√©es `yao`.

Votre sortie doit √™tre un jeu de donn√©es avec trois colonnes nomm√©es comme indiqu√© ci-dessous :

| sexe   | taille_min_cm | taille_max_cm |
|--------|---------------|---------------|
| Female |               |               |
| male   |               |               |

```{r eval = FALSE}

  yao %>% 
  ________________________
  ________________________
```
:::

::: practice
**Pratique 5**

Utilisez `group_by()`, `summarize()`, et la fonction `sum()` pour calculer le nombre total de jours alit√©s (de la variable `jours_alite`) rapport√©s par les r√©pondants de chaque sexe.

Votre sortie doit √™tre un jeu de donn√©es avec deux colonnes nomm√©es comme indiqu√© ci-dessous :

| sexe   | total_jours_alit√©s |
|--------|--------------------|
| Female |                    |
| Male   |                    |

```{r eval = FALSE}

  yao %>% 
  ________________________
  ________________________
```
:::

# Regroupement par plusieurs variables (groupement imbriqu√©)

Il est possible de regrouper un jeu de donn√©es par plus d'une variable. Ceci est parfois appel√© "groupement imbriqu√©".

Prenons un exemple. Supposons que vous voulez conna√Ætre l'√¢ge moyen des hommes et des femmes *dans chaque quartier* (plut√¥t que l'√¢ge moyen de *toutes* les femmes), vous pourriez mettre √† la fois `sexe` et `quartier` dans l'instruction `group_by()` :

```{r}
yao %>% 
  group_by(sexe, quartier) %>% 
  summarize(age_moyen = mean(age))
```

√Ä partir de ce jeu de donn√©es de sortie, vous pouvez voir que, par exemple, les femmes de Briqueterie ont un √¢ge moyen de 31,6 ans, tandis que les hommes de Briqueterie ont un √¢ge moyen de 33,7 ans.

L'ordre des colonnes list√©es dans `group_by()` est interchangeable. Donc, si vous ex√©cutez `group_by(quartier, sexe)` au lieu de `group_by(sexe, quartier)`, vous obtiendrez le m√™me r√©sultat, bien qu'il soit ordonn√© diff√©remment :

```{r}
yao %>% 
  group_by(quartier, sexe) %>% 
  summarize(age_moyen = mean(age))
```

Maintenant, l'ordre des colonnes est diff√©rent : `quartier` est la premi√®re colonne, et `sexe`est la deuxi√®me. Et l'ordre des lignes est √©galement diff√©rent : les lignes sont d'abord ordonn√©es par `quartier`, puis ordonn√©es par `sexe` √† l'int√©rieur de chaque quartier.

Mais les statistiques de r√©sum√© sont les m√™mes. Par exemple, vous pouvez √† nouveau voir que les femmes de Briqueterie ont un √¢ge moyen de 31,6 ans, tandis que les hommes de Briqueterie ont un √¢ge moyen de 33,7 ans.

::: practice
**Pratique 6**

En utilisant le jeu de donn√©es `yao`, groupez vos donn√©es par sexe (`sexe`) et traitements (`combinaisons_de_traitements`) en utilisant `group_by`. Ensuite, en utilisant `summarize()` et la fonction de statistique r√©capitulative appropri√©e, calculez le poids moyen (`poids_kg`) pour chaque groupe.

Votre sortie doit √™tre un jeu de donn√©es avec trois colonnes nomm√©es comme indiqu√© ci-dessous :

| sexe | combinaisons_de_traitements | poids_moyen_kg |
|------|-----------------------------|----------------|
|      |                             |                |

```{r, eval = FALSE}

  yao %>%
  ____________________________
```

En utilisant le jeu de donn√©es `yao`, groupez vos donn√©es par cat√©gorie d'√¢ge (`categorie_d_age_3`), genre (`sexe`), et r√©sultats d'IgG (`resultat_igg`) en utilisant `group_by`. Ensuite, en utilisant `summarize()` et la fonction de statistique r√©capitulative appropri√©e, calculez le nombre moyen de jours alit√©s (`n_jours_alit√©s`) pour chaque groupe.

Votre sortie doit √™tre un jeu de donn√©es avec quatre colonnes nomm√©es comme indiqu√© ci-dessous :

| categorie_d_age_3 | sexe | resultat_igg | moyenne_n_jours_alit√©s |
|-------------------|------|--------------|------------------------|
|                   |      |              |                        |

```{r, eval = FALSE}

  yao %>%
  ____________________________
```
:::

# D√©groupement avec `dplyr::ungroup()` (pourquoi et comment)

Quand vous utilisez `group_by()` pour plus d'une variable avant d'utiliser `summarize()`, le jeu de donn√©es de sortie reste group√©. Ce regroupement persistant peut avoir des effets ind√©sirables en aval, vous devrez donc parfois utiliser `dplyr::ungroup()` pour d√©grouper les donn√©es avant de faire une analyse plus pouss√©e.

Pour comprendre *pourquoi* vous devriez utiliser `ungroup()` sur les donn√©es, consid√©rez d'abord l'exemple suivant, o√π nous ne regroupons qu'une seule variable avant de calculer une statistique r√©capitulative :

```{r}
yao %>% 
  group_by(sexe) %>% 
  summarize(mean_age = mean(age))
```

Les donn√©es sont produites comme un jeu de donn√©es normal ; il n'est pas group√©. Vous pouvez le voir parce qu'il n'y a pas d'information sur les groupes dans l'en-t√™te.

Mais consid√©rez maintenant quand vous regroupez par deux variables avant de calculer une statistique r√©capitulative :

```{r}
yao %>% 
  group_by(sexe, quartier) %>% 
  summarize(mean_age = mean(age))
```

Maintenant, l'en-t√™te vous indique que les donn√©es sont toujours group√©es par la premi√®re variable dans `group_by()`, ici sexe :

```         
      # A tibble: 18 √ó 3
    üëâ# Groups:   sexe [2]üëà
```

Quelle est l'implication de ce regroupement persistant dans le jeu de donn√©es ? Cela signifie que le jeu de donn√©es peut montrer un comportement qui semble √©trange lorsque vous essayez d'appliquer certaines fonctions {dplyr} dessus.

Par exemple, si vous essayez de `select()` une seule variable, peut-√™tre la variable `mean_age`, vous devriez normalement pouvoir utiliser `select(mean_age)` :

```{r}
yao %>% 
  group_by(sexe, quartier) %>% 
  summarize(mean_age = mean(age)) %>% 
  select(mean_age) # ne fonctionne pas comme pr√©vu 
```

Mais comme vous pouvez le voir, la variable group√©e, `sex`, est *toujours* s√©lectionn√©e, m√™me si nous n'avons demand√© que `mean_age` dans l'instruction `select()`.

C'est l'un des nombreux exemples de comportements uniques des jeux de donn√©es group√©s. D'autres verbes dplyr comme `filter()`, `mutate()` et `arrange()` agissent √©galement de mani√®re sp√©ciale sur les donn√©es group√©es. Nous aborderons cela en d√©tail dans une le√ßon future.

------------------------------------------------------------------------

Vous savez donc maintenant *pourquoi* vous devriez d√©grouper les donn√©es lorsque vous n'en avez plus besoin. Voyons maintenant *comment* d√©grouper les donn√©es. C'est assez simple : il suffit d'ajouter la fonction `ungroup()` √† votre cha√Æne de pipe. Par exemple :

```{r}
yao %>% 
  group_by(sexe, quartier) %>% 
  summarize(mean_age = mean(age)) %>% 
  ungroup()
```

Maintenant que le jeu de donn√©es est d√©group√©, il se comportera √† nouveau comme un jeu de donn√©es normal. Par exemple, vous pouvez `select()` n'importe quelle colonne(s) que vous voulez ; vous n'aurez pas certaines colonnes ind√©sirables qui vous suivent :

```{r}
yao %>% 
  group_by(sexe, quartier) %>% 
  summarize(mean_age = mean(age)) %>% 
  ungroup() %>% 
  select(mean_age)
```

# Comptage des lignes

> Vous pouvez faire beaucoup de science des donn√©es en *comptant* simplement et occasionnellement en *divisant.* - Hadley Wickham, Scientifique Senior chez RStudio

Une t√¢che courante de statistique r√©capitulative des donn√©es est de compter combien d'observations (lignes) il y a pour chaque groupe. Vous pouvez y parvenir avec la fonction sp√©ciale `n()` de {dplyr}, qui est sp√©cifiquement con√ßue pour √™tre utilis√©e dans `summarise()`.

Par exemple, si vous voulez compter combien d'individus se trouvent dans chaque groupe de quartier, vous ex√©cuteriez :

```{r}
yao %>% 
  group_by(quartier) %>% 
  summarize(nombre = n())
```

Comme vous pouvez le voir, la fonction `n()` ne n√©cessite aucun argument. Elle "connait son travail" dans le jeu de donn√©es !

------------------------------------------------------------------------

Bien s√ªr, vous pouvez inclure d'autres statistiques r√©capitulatives dans le m√™me appel `summarize()`. Par exemple, ci-dessous, nous calculons √©galement l'√¢ge moyen par quartier.

```{r}
yao %>% 
  group_by(quartier) %>% 
  summarize(nombre = n(), 
            mean_age = mean(age))
```

::: practice
**Pratique 7**

Groupez votre jeu de donn√©es `yao` par l'occupation des r√©pondants (`occupation`) et utilisez `summarize()` pour cr√©er des colonnes qui montrent :

-   combien d'individus il y a avec chaque occupation (pensez √† la fonction `n()`)
-   le nombre moyen de jours de travail manqu√©s (`jours_absence_travail`) par ceux ayant cette occupation

Votre sortie doit √™tre un jeu de donn√©es avec trois colonnes nomm√©es comme indiqu√© ci-dessous :

| occupation | count | mean_jours_absence_travail |
|------------|-------|----------------------------|
|            |       |                            |

```{r, eval = FALSE}

  yao %>%
  ____________________________
```
:::

## Compter les lignes qui r√©pondent √† une condition

Plut√¥t que de compter *toutes* les lignes comme ci-dessus, il est parfois plus utile de compter seulement les lignes qui r√©pondent √† des conditions sp√©cifiques. Cela peut √™tre fait facilement en pla√ßant les conditions requises dans la fonction `sum()`.

Par exemple, pour compter le nombre de personnes de moins de 18 ans dans chaque quartier, vous placez la condition `age < 18` √† l'int√©rieur de `sum()` :

```{r}
yao %>% 
  group_by(quartier) %>% 
  summarize(nombre_inferieur_18 = sum(age < 18))
```

------------------------------------------------------------------------

De m√™me, pour compter le nombre de personnes ayant un doctorat dans chaque quartier, vous placez la condition `edu_haute == "Doctorate"` √† l'int√©rieur de `sum()` :

```{r}
yao %>% 
  group_by(quartier) %>% 
  summarize(nombre_avec_doctorates = sum(edu_haute == "Doctorate"))
```

::: challenge
**Sous le capot : compter avec des conditions**

Pourquoi pouvez-vous utiliser `sum()`, qui est cens√© ajouter des nombres, sur une condition comme `edu_haute == "Doctorate"` ?

Utiliser `sum()` sur une condition fonctionne parce que la condition √©value aux valeurs bool√©ennes `TRUE` et `FALSE`. Et ces valeurs bool√©ennes sont trait√©es comme des nombres (o√π `TRUE` est √©gal √† 1 et `FALSE` est √©gal √† 0), et les nombres peuvent, bien s√ªr, √™tre somm√©s.

Le code ci-dessous d√©montre ce qui se passe sous le capot de mani√®re √©tape par √©tape. Ex√©cutez-le et voyez si vous pouvez suivre.

```{r}
demo_of_condition_sums <- yao %>% 
  select(edu_haute) %>% 
  mutate(avec_doctorate = edu_haute == "Doctorate") %>% 
  mutate(numerique_avec_doctorate = as.numeric(avec_doctorate))

demo_of_condition_sums
```

Les valeurs num√©riques peuvent ensuite √™tre ajout√©es pour produire un d√©compte des lignes remplissant la condition `edu_haute == "Doctorate"` :

```{r}
demo_of_condition_sums %>% 
  summarize(nombre_avec_doctorate = sum(numerique_avec_doctorate))
```
:::

------------------------------------------------------------------------

Pour une illustration finale du comptage avec des conditions, consid√©rez la variable `combinaisons_traitement`, qui liste les traitements re√ßus par les personnes pr√©sentant des sympt√¥mes similaires √† ceux du COVID. Les personnes qui n'ont re√ßu aucun traitement ont une valeur `NA` :

```{r}
yao %>% 
  select(combinaisons_traitement)
```

Si vous voulez compter le nombre de personnes qui n'ont re√ßu *aucun traitement*, vous additionneriez celles qui r√©pondent √† la condition `is.na(combinaisons_traitement)` :

```{r}
yao %>% 
  group_by(quartier) %>% 
  summarize(traitement_inconnu = sum(is.na(combinaisons_traitement)))
```

Ce sont les personnes ayant des valeurs `NA` pour la colonne `combinaisons_traitement`.

Pour compter les personnes qui *ont* re√ßu un traitement, vous pouvez simplement nier la fonction `is.na()` avec `!` :

```{r}
yao %>%  group_by(quartier) %>% 
  summarize(traitment_connu = sum(!is.na(combinaisons_traitement)))
```

VEUILLEZ IGNORER LA QUESTION PRATIQUE SUR LA V√âRIFICATION DES SYMPT√îMES CHEZ LES ADULTES. NOUS AVONS D√âCID√â DE LA SUPPRIMER.

## dplyr::count()

La fonction `dplyr::count()` regroupe plusieurs choses en une seule ligne de code conviviale pour vous aider √† trouver les comptages d'observations par groupe.

Utilisons `dplyr::count()` sur notre variable `occupation` :

```{r}
yao %>%
  count(occupation)
```

Notez que c'est la m√™me sortie que :

```{r}
yao %>%
  group_by(occupation) %>% 
  summarize(n = n())
```

Vous pouvez √©galement appliquer `dplyr::count()` de mani√®re imbriqu√©e :

```{r}
yao %>%
  count(sexe, occupation)
```

::: practice
**Pratique 8**

Le verbe `count()` vous donne des informations cl√©s sur votre ensemble de donn√©es de mani√®re tr√®s rapide. Regardons nos r√©sultats IgG stratifi√©s par cat√©gorie d'√¢ge et par sexe en une seule ligne de code.

En utilisant le jeu de donn√©es `yao`, comptez les diff√©rentes combinaisons de genre (`sex`), de cat√©gories d'√¢ge (`cat_age_3`) et de r√©sultats IgG (`resultat_igg`).

Votre sortie doit √™tre un jeu de donn√©es avec quatre colonnes nomm√©es comme indiqu√© ci-dessous :

| sexe | cat_age_3 | resultat_igg | n   |
|------|-----------|--------------|-----|
|      |           |              |     |

```{r, eval = FALSE}

  yao %>%
  ____________________________
```

En utilisant le jeu de donn√©es `yao`, comptez les diff√©rentes combinaisons de cat√©gories d'√¢ge (`cat_age_3`) et de nombre de jours alit√©s (`jours_alite`).

Votre sortie doit √™tre un jeu de donn√©es avec trois colonnes nomm√©es comme indiqu√© ci-dessous :

| cat_age_3 | jours_alite | n   |
|-----------|-------------|-----|
|           |             |     |

```{r, eval = FALSE}
Q_count_bedridden_age_categories <- 
  yao %>%
  ____________________________
```
:::

------------------------------------------------------------------------

L'inconv√©nient de `count()` est qu'il ne peut vous donner qu'une seule statistique r√©capitulative dans le jeu de donn√©es. Lorsque vous utilisez `summarize()` et `n()`, vous pouvez inclure plusieurs statistiques r√©capitulatives. Par exemple :

```{r}
yao %>% 
  group_by(sexe, quartier) %>% 
  summarize(count = n(), 
            median_age = median(age))
```

Mais `count()` ne peut produire que des comptages :

```{r}
yao %>% 
  group_by(sexe, quartier) %>% 
  count()
```

# Inclure les combinaisons manquantes dans les statistiques r√©capitulatives

Lorsque vous utilisez `group_by()` et `summarize()` sur plusieurs variables, vous obtenez une statistique r√©capitulative pour chaque combinaison unique des variables group√©es. Par exemple, consid√©rez le code et la sortie ci-dessous, qui comptent le nombre d'individus dans chaque groupe d'√¢ge et de sexe :

```{r}
yao %>% 
  group_by(sexe, cat_age_3) %>% 
  summarise(nombre_d_individus = n()) 
```

Dans le jeu de donn√©es de sortie, il y a une ligne pour chaque combinaison de sexe et de groupe d'√¢ge (Femme---Adulte, Femme---Enfant, etc.).

Mais que se passe-t-il si l'une de ces combinaisons n'est pas pr√©sente dans les donn√©es ?

Cr√©ons un exemple artificiel pour observer cela. Avec le code ci-dessous, nous supprimons artificiellement tous les enfants de sexe masculin du jeu de donn√©es `yao` :

```{r}
yao_no_male_children <- 
  yao %>% 
  filter(!(sexe == "Male" & cat_age_3 == "Child"))
```

Maintenant, si vous ex√©cutez le m√™me appel `group_by()` et `summarize()` sur `yao_no_male_children`, vous remarquerez la combinaison manquante :

```{r}
yao_no_male_children %>% 
  group_by(sexe, cat_age_3) %>% 
  summarise(number_of_individuals = n())
```

En effet, il n'y a pas de ligne pour les enfants de sexe masculin.

Mais parfois, il est utile d'inclure ces combinaisons manquantes dans le jeu de donn√©es de sortie, avec une valeur `NA` ou 0 pour la statistique r√©capitulative.

Pour ce faire, vous pouvez ex√©cuter le code suivant √† la place :

```{r}
yao_no_male_children %>% 
  # convertir les variables en facteurs
  mutate(sexe = as.factor(sexe), 
         cat_age_3 = as.factor(cat_age_3)) %>% 
  # Notez l'argument .drop = FALSE
  group_by(sexe, cat_age_3, .drop = FALSE) %>% 
  summarise(number_of_individuals = n())
```

Que fait ce code ?

-   D'abord, il convertit les variables de regroupement en facteurs avec `as.factor()` (dans un appel √† `mutate()`)

-   Ensuite, il utilise l'argument `.drop = FALSE` dans la fonction `group_by()` pour √©viter de supprimer les combinaisons manquantes.

Vous avez maintenant un compte clair de `0` pour le nombre d'enfants de sexe masculin !

------------------------------------------------------------------------

Voyons un autre exemple, cette fois sans modifier artificiellement nos donn√©es.

Le code ci-dessous calcule l'√¢ge moyen par sexe et par niveau d'√©ducation :

```{r}
yao %>% 
  group_by(sexe, edu_haute) %>% 
  summarise(mean_age = mean(age))
```

Remarquez que dans le jeu de donn√©es de sortie, il y a 7 lignes pour les hommes mais seulement 6 lignes pour les femmes, car aucune femme n'a r√©pondu "Autre" √† la question sur le niveau d'√©ducation le plus √©lev√©.

Si vous voulez n√©anmoins inclure la ligne "Femme---Autre" dans le jeu de donn√©es de sortie, vous ex√©cuteriez :

```{r}
yao %>% 
  mutate(sexe = as.factor(sexe), 
         edu_haute = as.factor(edu_haute)) %>% 
  group_by(sexe, edu_haute, .drop = FALSE) %>% 
  summarise(mean_age = mean(age))
```

::: practice
**Pratique 9**

En utilisant le jeu de donn√©es `yao`, calculons l'√¢ge m√©dian en regroupant par quartier, cat√©gorie d'√¢ge et sexe.

Notez que nous voulons toutes les combinaisons possibles de ces trois variables (pas seulement celles pr√©sentes dans nos donn√©es).

Faites attention √† deux imp√©ratifs de pr√©paration des donn√©es !

-   convertissez vos variables de regroupement en facteurs au pr√©alable en utilisant `mutate()`
-   calculez votre statistique, la m√©diane, tout en supprimant les valeurs `NA`.

Votre sortie doit √™tre un jeu de donn√©es avec quatre colonnes nomm√©es comme indiqu√© ci-dessous :

| quartier | cat_age_3 | sexe | median_age |
|----------|-----------|------|------------|
|          |           |      |            |

```{r, eval = FALSE}

  yao %>%
  ____________________________
```
:::

::: side-note
**Pourquoi inclure les combinaisons manquantes ?**

Ci-dessus, nous avons mentionn√© que l'inclusion de combinaisons manquantes est souvent utile dans le processus d'analyse de donn√©es. Voyons un cas d'utilisation : la conception des graphiques avec {ggplot}. Si vous n'avez pas encore appris {ggplot}, ce n'est pas grave, concentrez-vous simplement sur les sorties de graphique.

Pour r√©aliser un diagramme √† barres compos√© avec les comptes d'√¢ge-sexe de `yao_no_male_children`, vous pourriez ex√©cuter :

```{r}
yao_no_male_children %>% 
  group_by(sexe, cat_age_3) %>% 
  summarise(nombre_d_individus = n()) %>% 
  ungroup() %>% 
  
  # transmettre la sortie √† ggplot
  ggplot() + 
  geom_col(aes(x = sexe, y = nombre_d_individus, fill = cat_age_3), 
           position = "dodge")
```

Pas tr√®s √©l√©gant ! Id√©alement, il devrait y avoir un espace vide indiquant 0 pour le nombre d'enfants de sexe masculin.

Si vous mettez en ≈ìuvre la proc√©dure pour inclure les combinaisons manquantes, vous obtenez un diagramme √† barres compos√© plus naturel, avec un espace vide pour les enfants de sexe masculin :

```{r}
yao_no_male_children %>% 
  mutate(sexe = as.factor(sexe), 
         cat_age_3 = as.factor(cat_age_3)) %>% 
  group_by(sexe, cat_age_3, .drop = FALSE) %>% 
  summarise(nombre_d_individus = n()) %>% 
  ungroup() %>% 
  
  # transmettre la sortie √† ggplot
  ggplot() + 
  geom_col(aes(x = sexe, y = nombre_d_individus, fill = cat_age_3), 
           position = "dodge")
```

Beaucoup mieux !

Au fait, cette sortie peut √™tre l√©g√®rement am√©lior√©e en d√©finissant les niveaux de facteur pour l'√¢ge dans leur ordre croissant correct : d'abord "Enfant", puis "Adulte" puis "Senior" :

```{r}
yao_no_male_children %>% 
  mutate(sexe = as.factor(sexe), 
         cat_age_3 = factor(cat_age_3, 
                                 levels = c("Enfant", 
                                            "Adulte", 
                                            "Senior"))) %>% 
  group_by(sexe, cat_age_3, .drop = FALSE) %>% 
  summarise(nombre_d_individus = n()) %>% 
  ungroup() %>% 
  
  # transmettre la sortie √† ggplot
  ggplot() + 
  geom_col(aes(x = sexe, y = nombre_d_individus, fill = cat_age_3), 
           position = "dodge")
```
:::

# Conclusion

Vous avez maintenant vu comment obtenir des statistiques r√©capitulatives rapides √† partir de vos donn√©es, soit pour l'exploration de donn√©es, soit pour une pr√©sentation ou une visualisation de donn√©es suppl√©mentaires.

De plus, vous avez d√©couvert l'une des merveilles de {dplyr}, la possibilit√© de grouper vos donn√©es √† l'aide de `group_by()`.

`group_by()` combin√© avec `summarize()` est l'une des manipulations de regroupement les plus courantes.

![Fig: summarize() et son utilisation combin√©e avec group_by().](images/custom_dplyr_groupby_summarize.png){width="400"}

Cependant, vous pouvez √©galement combiner `group_by()` avec de nombreux autres verbes {dplyr} : c'est ce que nous couvrirons dans notre prochaine le√ßon. √Ä bient√¥t !

# Contributeurs {.unlisted .unnumbered}

Les membres suivants de l'√©quipe ont contribu√© √† cette le√ßon:

`r tgc_contributors_list(ids = c("lolovanco", "avallecam", "kendavidn"))`

Merci √† [Alice Osmaston](https://thegraphcourses.org/members/alice){target="_blank"} et [Saifeldin Shehata](https://thegraphcourses.org/members/saif){target="_blank"} pour leurs commentaires et leur revue.

# R√©f√©rences {.unlisted .unnumbered}

Certaines informations de cette le√ßon ont √©t√© adapt√©es des sources suivantes :

-   Horst, A. (2022). *Dplyr-learnr*. <https://github.com/allisonhorst/dplyr-learnr> (Travail original publi√© en 2020)

-   *Group by one or more variables*. (s.d.). Consult√© le 21 f√©vrier 2022, sur <https://dplyr.tidyverse.org/reference/group_by.html>

-   *Summarise each group to fewer rows*. (s.d.). Consult√© le 21 f√©vrier 2022, sur <https://dplyr.tidyverse.org/reference/summarize.html>

-   The Carpentries. (s.d.). *Grouped operations using \`dplyr\`*. Grouped operations using \`dplyr\` -- Introduction to R/tidyverse for Exploratory Data Analysis. Consult√© le 28 juillet 2022, sur <https://tavareshugo.github.io/r-intro-tidyverse-gapminder/06-grouped_operations_dplyr/index.html>

L'≈ìuvre d'art a √©t√© adapt√©e de :

-   Horst, A. (2022). *R & stats illustrations by Allison Horst*. <https://github.com/allisonhorst/stats-illustrations> (Travail original publi√© en 2018)

```{r, include = F}
```

# Solutions des exercices pratiques

*Solution exercice pratique 1*

```{r}
yao %>%
  summarize(mean_poids_kg = mean(poids_kg),
            median_poids_kg = median(poids_kg),
            sd_poids_kg = sd(poids_kg))
```

*Solution exercice pratique 2*

```{r}
yao %>%
  summarize(min_taille_cm = min(taille_cm),
            max_taille_cm = max(taille_cm))
```

*Solution exercice pratique 3*

```{r}

yao %>% 
  group_by(fumeur) %>% 
  summarise(poids_mean = mean(poids_kg))
```

*Solution exercice pratique 4*

```{r}

yao %>% 
  group_by(sexe) %>%
  summarise(min_taille_cm = min(taille_cm),
            max_taille_cm = max(taille_cm))
```

*Solution exercice pratique 5*

```{r}
yao %>% 
  group_by(sexe) %>% 
  summarise(total_jours_alite = sum(jours_alite, na.rm = T))
```

*Solution exercice pratique 6_1*

```{r}
yao %>% 
  group_by(sexe, combinaisons_traitement) %>%
  summarise(mean_poids_kg = mean(poids_kg, na.rm = T))
```

*Solution exercice pratique 6_2*

```{r}
yao %>% 
  group_by(cat_age_3, sexe, resultat_igg) %>% 
  summarise(mean_jours_alite = mean(jours_alite, na.rm = T))
```

*Solution exercice pratique 7*

```{r}
yao %>% 
  group_by(occupation) %>%
  summarise(count = n(),
            mean_jours_absence_travail = mean(jours_absence_travail, na.rm=TRUE))
```

*Solution exercice pratique 8_1*

```{r}
yao %>% 
  count(sexe, cat_age_3, resultat_igg)

```

*Solution exercice pratique 8_2*

```{r}
yao %>% 
  count(cat_age_3, jours_alite)

```

*Solution exercice pratique 9*

```{r}
yao %>% 
  mutate(quartier = as.factor(quartier),
         cat_age_3 = as.factor(cat_age_3),
         sexe = as.factor(sexe)) %>%
  group_by(quartier, cat_age_3, sexe, .drop=FALSE) %>%
  summarize(median_age = median(age, na.rm=TRUE))
```
